  public function CalculateWorkTime28Hour ($UserEmployIDList, $mergeShopID,
                                        $LatestWorkID, $LatestWorkStartTime, $LatestWorkEndTime,
                                        $LatestStartBreakTime, $LatestBreak, $CurrentDate, $CurrentDateTime,
                                        $ShopIDList, $_28CheckStartDate, $_28CheckEndDate, $isCheckDesignation,
                                        $SearchShiftType, $TotalType) {
        $rs["TodayWorkHour"] = "00:00:00";
        $rs["ClockIn"] = '';
         $TodayWorkHour = "00:00:00";
        $AttendanceTbl = $this->getTableLocator()->get('Attendance');
        $ScheduleTbl = $this->getTableLocator()->get('Schedule');
        $auth = $this->getAuth();
        $LatestWorkStart = null;
        $LatestWorkEnd = null;
        //LoginUserのuser_id
         $userId = $auth->id;
        //・前日からの労働時間を計算する。
         if (!is_null($LatestWorkStartTime)) {
            //LatestWorkStartTimeのDate
            $LatestWorkStart = date('Y-m-d', strtotime($LatestWorkStartTime));
        }
        if (!is_null($LatestWorkEndTime)) {
            //LatestWorkEndTimeのDate
            $LatestWorkEnd = date('Y-m-d', strtotime($LatestWorkEndTime));
        }
        $TotalWorkHour = "00:00:00";
        $hour = "00:00:00";

        //----1---・前日からの労働時間を計算する。
        //・最新の打刻情報が取得できた場合 ( LatestWorkID != null )
        if (!is_null($LatestWorkID)) {
            //---------------log start---------------------
            $this->writeLog28h('UserController', 'CalculateWorkTime28Hour', '28 hour limit - 最新の打刻情報が取得できた場合 ( LatestWorkID != null )', '', $CurrentDate, '');
            //---------------log end------------------------
            //・ LatestWorkStartTimeのDate < CurrentDate AND LatestWorkEndTime = null の場合、下記の処理を行う。
            if($LatestWorkStart < $CurrentDate && is_null($LatestWorkEndTime)) {
                //・休憩中の場合（ LatestStartBreakTime != null）
                if(!is_null($LatestStartBreakTime)) {
                    $start1 = $LatestWorkStartTime;
                    $end1   = $CurrentDate . " 00:00:00";
                    $start2 = $end1;
                    $end2   = ($LatestStartBreakTime <=  $end1) ? $end1 : $LatestStartBreakTime;
                    $break  = $LatestBreak;
                } else {
                    //・休憩中以外の場合（ LatestStartBreakTime = null）
                    $start1 = $LatestWorkStartTime;
                    $end1   = $CurrentDate . " 00:00:00";
                    $start2 = $end1;
                    $end2   = $CurrentDateTime;
                    $break  = $LatestBreak;
                    $rs["ClockIn"] = "yes";
                }

                //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                $TodayWorkHour = $data["WorkHour"];
            }
            //・ LatestWorkStartTimeのDate < CurrentDate AND LatestWorkEndTimeのDate = CurrentDate の場合、下記の処理を行う。
            if ($LatestWorkStart < $CurrentDate && $LatestWorkEnd === $CurrentDate) {
                $start1 = $LatestWorkStartTime;
                $end1   = $CurrentDate . " 00:00:00";
                $start2 = $end1;
                $end2   = $LatestWorkEndTime;
                $break  = $LatestBreak;
                //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                $TodayWorkHour = $data["WorkHour"];
            }
        }
        //・最新の打刻が取得できない OR 最新打刻が当日の場合、下記の処理を行う。( LatestWorkID = null OR LatestWorkStartTimeのDate = CurrentDate )
        // if (is_null($LatestWorkID) || $LatestWorkStart === $CurrentDate) {
            //---------------log start---------------------
            $this->writeLog28h('UserController', 'CalculateWorkTime28Hour', '28 hour limit - 最新の打刻が取得できない OR 最新打刻が当日の場合、下記の処理を行う。( LatestWorkID = null OR LatestWorkStartTimeのDate = CurrentDate )', '', $CurrentDate, '');
            //---------------log end------------------------
            $DayBeforeStartWorkTime = null;
            $DayBeforeStartBreak = null;
            $DayBeforeEndWorkTime = null;
            $dtAttPre = $AttendanceTbl->getAttendancePreDay($UserEmployIDList, $mergeShopID, $CurrentDate, $LatestWorkID);
            if (sizeof($dtAttPre) > 0) {
                $WorkHour = "00:00:00";
                for ($i=0; $i < sizeof($dtAttPre); $i++) {
                    //・Record件数 > 0 の場合は、労働時間を計算する。
                    $DayBeforeStartWorkTime = $dtAttPre[$i]->start;
                    $DayBeforeStartBreak = $dtAttPre[$i]->break;
                    $DayBeforeEndWorkTime = $dtAttPre[$i]->end;

                    $start1 = $DayBeforeStartWorkTime;
                    $end1   = $CurrentDate . " 00:00:00";
                    $start2 = $end1;
                    $end2   = $DayBeforeEndWorkTime;
                    $break  = $DayBeforeStartBreak;
                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                    $WorkHour = $this->summationTime($WorkHour, $data["WorkHour"]);
                }
                $TodayWorkHour = $this->summationTime($TodayWorkHour, $WorkHour);
            }
        // }
        //----2---・当日の労働時間を取得する。
        //・最新の打刻が取得できた( LatestWorkID != null ) AND LatestWorkStartTimeのDate = CurrentDate の場合、下記の処理を行う。
        if (!is_null($LatestWorkID) && ($LatestWorkStart === $CurrentDate)) {
            //---------------log start---------------------
            $this->writeLog28h('UserController', 'CalculateWorkTime28Hour', '28 hour limit - 当日の労働時間を取得する。- 最新の打刻が取得できた( LatestWorkID != null ) AND LatestWorkStartTimeのDate = CurrentDate の場合', '', $CurrentDate, '');
            //---------------log end------------------------
            //・最新の勤怠以前の労働時間を計算する。
            $total = "00:00:00";
            $dtAttenLast = $AttendanceTbl->getAttenLast($UserEmployIDList, $mergeShopID, $CurrentDate, $LatestWorkID, $CurrentDateTime);
            if (sizeof($dtAttenLast) > 0) {
                for ($i=0; $i < sizeof($dtAttenLast); $i++) {
                    $StartWorkTime = $this->checkNullFormatDate($dtAttenLast[$i]["start"], 'Y-m-d H:i:00');
                    $Break =  $dtAttenLast[$i]["break"];
                    $EndWorkTime = $this->checkNullFormatDate($dtAttenLast[$i]["end"], 'Y-m-d H:i:00');

                    $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $EndWorkTime, $Break);
                    //集計項目
                    $total = $this->summationTime($total, $WorkHour);
                }
            }
            //・最新の労働時間を足す。
            $hour = "00:00:00";
            if (!is_null($LatestWorkEndTime)) {
                //TodayWorkHour + ( LatestWorkEndTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $LatestWorkEndTime, $LatestBreak);
                $TotalWorkHour = $this->summationTime($total, $hour);
            } else {
                if (is_null($LatestStartBreakTime)) {
                    //TodayWorkHour + ( CurrentDateTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                    $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $CurrentDateTime, $LatestBreak);
                    $TotalWorkHour = $this->summationTime($total, $hour);
                    $rs["ClockIn"] = "yes";
                } else  {
                    //TodayWorkHour + ( LatestStartBreakTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                    $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $LatestStartBreakTime, $LatestBreak);
                    $TotalWorkHour = $this->summationTime($total, $hour);
                }
            }
        }
        //・未連携店舗の集計
        $dataUnlinkShiftDB = $ScheduleTbl->getUnlinkedShiftTimeBeforeTarget($userId, $CurrentDate, $isCheckDesignation);
        $TargetDayUserShiftHour = '00:00:00';
        for ($i=0; $i < sizeof($dataUnlinkShiftDB); $i++) {
            $ele = $dataUnlinkShiftDB[$i];
            $StartUserShiftTime = $this->checkNullFormatDate($ele["start"], 'Y-m-d H:i:00');
             $Break = $ele["break"];
            $CurrentNext = date( 'Y-m-d 00:00:00', strtotime('+1 day' , strtotime ($CurrentDate)));
            $EndUserShiftTime = $this->checkNullFormatDate($ele["end"], 'Y-m-d H:i:00');
            if ($EndUserShiftTime > $CurrentNext) $EndUserShiftTime = $CurrentNext;
            $pastShiftHour = $this->calWorkTimeToBreak($StartUserShiftTime, $EndUserShiftTime, $Break);
            $TargetDayUserShiftHour = $this->summationTime($TargetDayUserShiftHour , $pastShiftHour);
        }
        //・指定日の前日からの未連携シフト時間
        $CurrentPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ($CurrentDate)));
        $dataUnlinkShiftInTargetDB = $ScheduleTbl->getUnlinkedShiftTimeInTarget($userId, $CurrentPre, $CurrentDate, $isCheckDesignation);
        for ($i=0; $i < sizeof($dataUnlinkShiftInTargetDB); $i++) {
            $ele = $dataUnlinkShiftInTargetDB[$i];
            $DayAgoStartUserShiftTime = $this->checkNullFormatDate($ele["start"], 'Y-m-d H:i:00');
            $DayAgoUserShiftBreak = $ele["break"];
            $DayAgoEndUserShiftTime = $this->checkNullFormatDate($ele["end"], 'Y-m-d H:i:00');

            $start1 = $DayAgoStartUserShiftTime;
            $end1   = $CurrentDate . " 00:00:00";
            $start2 = $end1;
            $end2   = $DayAgoEndUserShiftTime;
            $break  = $DayAgoUserShiftBreak;
            //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
            $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);

            $TargetDayUserShiftHour = $this->summationTime($TargetDayUserShiftHour , $data["WorkHour"]);
        }

        $TodayWorkHour = $this->summationTime($TodayWorkHour, $TotalWorkHour);
        $TodayWorkHour = $this->summationTime($TodayWorkHour, $TargetDayUserShiftHour);

        //・過去の労働時間を計算する。
        $datePre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $CurrentDate )));
        $PatternPast = [];
        for ($i=0; $i < 6; $i++) {
            //・Pattern1-6（-6日から-1日までのPattern）分を取得する。
            $num = 6 - $i;
            $start = date( 'Y-m-d 00:00:00', strtotime('-'. (int) $num .' day' , strtotime ( $CurrentDate )));
            if ( $start < $_28CheckStartDate . " 00:00:00" ) $start = $_28CheckStartDate . " 00:00:00";
            $arr = [
                "start" => $start,
                "end" => date( 'Y-m-d 00:00:00', strtotime('-1 day' , strtotime ( $CurrentDate )))
            ];
            array_push($PatternPast, $arr);
            $PatternPast[$i]["WorkHour"] = "00:00:00";
        }
        //CurrentDate - 1Day が長期休暇の場合、Pattern1-6の過去の労働時間は集計しない。 ( 28CheckStartDate = CurrentDate の場合、過去の労働時間の集計は行わない)
        if ( $_28CheckStartDate != $CurrentDate) {
            //・ UserEmployIDList の件数 = 0 の場合は「・未連携店舗のシフト時間」を実施する。
            //----2---・連携店舗の労働時間
            //---------------log start---------------------
            $this->writeLog28h('UserController', 'CalculateWorkTime28Hour', '28 hour limit - ・連携店舗の労働時間', '', $CurrentDate, '');
            //---------------log end------------------------
            for ($i=0; $i < 6; $i++) {
                $startPattern = date('Y-m-d', strtotime($PatternPast[$i]["start"]));
                if (sizeof($UserEmployIDList) > 0) {
                    //・連携店舗の労働時間
                    //長期休暇が存在するため、28CheckStartDateまたは28CheckEndDate が Pattern1-6 の期間と一致しない場合があるため、長期休暇日を集計しないように注意すること。
                    $TotalWorkHour28h = "00:00:00";
                    $dtAtten = $AttendanceTbl->getAttendance28h($mergeShopID, $UserEmployIDList, $startPattern, $datePre);
                    foreach ($dtAtten as $key => $value) {
                        $StartWorkTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                        // $dtBreak = $value["break_times"];
                        $Break = $value["break_times"];
                        $date = $this->checkNullFormatDate($value["date"], 'Y-m-d');
                        if ( $date === $datePre ) {
                            $Break = (is_null($Break)) ? $LatestBreak : $Break;
                        }
                        $Break = (is_null($Break)) ? 0 : $Break;
                        $endTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');

                        // if ($this->checkNullFormatDate($value["date"], 'Y-m-d') === $datePre) {
                        $EndWorkTime = (is_null($endTime)) ? $CurrentDateTime : $endTime ;
                        // } else {
                        //     $EndWorkTime = $endTime;
                        // }
                        // //CurrentDate - 1Dayから労働中(退勤時間が全てnull)の場合は、退勤時間はCurrentDateTimeで扱う。
                        // if (is_null($EndWorkTime)) $EndWorkTime = $CurrentDateTime;

                        //IF(EndWorkTime > CurrentDate + ' 00:00:00', CurrentDate + ' 00:00:00',  EndWorkTime) - StartWorkTime - Break
                        if ($EndWorkTime > $CurrentDate . " 00:00:00") {
                            $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $CurrentDate . " 00:00:00", $Break);
                        } else {
                            $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $EndWorkTime, $Break);
                        }
                        //集計項目
                        $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $WorkHour);
                    }
                    //PatternPast[]	← SUM(WorkHour)
                    $PatternPast[$i]["WorkHour"] = $this->summationTime($PatternPast[$i]["WorkHour"], $TotalWorkHour28h);

                    $dtAttenPre = $AttendanceTbl->getAttendancePreDay($UserEmployIDList, $mergeShopID, $startPattern);
                    $TotalWorkHour28h = "00:00:00";
                    foreach ($dtAttenPre as $key => $value) {
                        //・Record件数 > 0 の場合は、労働時間を計算する。
                        $DayBeforeStartWorkTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                        $DayBeforeStartBreak = $value->break;
                        $DayBeforeEndWorkTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');

                        $start1 = $DayBeforeStartWorkTime;
                        $end1   = $startPattern . " 00:00:00";
                        $start2 = $end1;
                        $end2   = $DayBeforeEndWorkTime;
                        $break  = $DayBeforeStartBreak;
                        //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                        $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                        //集計項目
                        $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $data["WorkHour"]);
                    }
                    //PatternPast[]	 ←	PatternPast[] + 計算した労働時間
                    $PatternPast[$i]["WorkHour"] = $this->summationTime($PatternPast[$i]["WorkHour"], $TotalWorkHour28h);

                    //・連携店舗の確定シフト時間
                    //ShopIDList のshop_id単位で以下の処理をLoopする。
                    $mergeShop = [];
                    for ($y=0; $y < sizeof($ShopIDList); $y++) {
                        array_push($mergeShop, (int) $ShopIDList[$y]["shop_id"]);
                        // if(isset($ShopIDList[$y]["NotAffiliationShopIDList"])){
                        //     foreach ($ShopIDList[$y]["NotAffiliationShopIDList"] as $key => $value) {
                        //         array_push($mergeShop, (int) $value["id"]);
                        //     }
                        // }
                    }
                    for ($z=0; $z < sizeof($ShopIDList); $z++) {
                        // < PatternPast[] の開始日 <= ShopIDList[].FirstClockInのDate の場合、または最初の打刻が無い場合( ShopIDList[].FirstClockIn = null )のみ集計処理を行う。
                        //・最初の打刻日が無い場合 (ShopIDList[].FirstClockIn = null の場合)
                        //・Pattern1-6（-6日から-1日までのPattern）分を取得する。
                        if (!isset($ShopIDList[$z]["FirstClockIn"]) || is_null($ShopIDList[$z]["FirstClockIn"])) {
                            //・対象期間開始日から、当日-1日までの労働時間
                            //長期休暇が存在するため、28CheckStartDateまたは28CheckEndDate が Pattern1-6 の期間と一致しない場合があるため、長期休暇日を集計しないように注意すること。
                            // $dtSchedule = $ScheduleTbl->getScheduleShiftPattern($ShopIDList[$z]["employee_id"], $mergeShop, $startPattern, $datePre, $AppNotStampedShiftType);
                            // $totalShiftHour = "00:00:00";
                            // foreach ($dtSchedule as $key => $value) {
                            //     //以下の時間を取得する。  'temp_shift'の場合は希望シフト時間を取得する。0.11.0b
                            //     //StartShiftTime			            ←		IF(  type = 'temp_shift', [`work`.schedules].update_start, [`work`.schedules].start )
                            //     $StartShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //     //Break						            ←		IF ( type = 'temp_shift', [`work`.schedules].update_break_times, [`work`.schedules].break_times )
                            //     $Break = $this->isTempShift($value->type) ? $value->update_break_times : $value->break;
                            //     //EndShiftTime						    ←		IF ( type = 'temp_shift' , [`work`.schedules].update_end, [`work`.schedules].end )
                            //     $EndShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                            //     //IF(EndWorkTime > CurrentDate + ' 00:00:00', CurrentDate + ' 00:00:00',  EndWorkTime) - StartWorkTime - Break
                            //     //ShiftHour が、マイナス時間になる場合は 0:00 にする。
                            //     if ($EndShiftTime > $CurrentDate . " 00:00:00") {
                            //         $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $CurrentDate . " 00:00:00", $Break);
                            //     } else {
                            //         $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                            //     }
                            //     //集計項目
                            //     $totalShiftHour = $this->summationTime($totalShiftHour, $ShiftHour);

                            //     // $start1 = $DayBeforeStartShiftTime;
                            //     // $end1   = $startPattern . " 00:00:00";
                            //     // $start2 = $end1;
                            //     // $end2   = $DayBeforeEndUserTime;
                            //     // $break  = $DayBeforeBreak;
                            //     // //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            //     // $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //     // //集計項目
                            //     // $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                            // }
                            //PatternPast[]	 ←	PatternPast[] + 計算した労働時間
                            // $PatternPast[$i]["WorkHour"] = $this->summationTime($PatternPast[$i]["WorkHour"], $totalShiftHour);

                            //・Pattern1-6の対象期間開始日の前日からのシフト時間
                            // $startPatternPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $startPattern )));
                            // $dtScheduleDay = $ScheduleTbl->getScheduleALLShiftTarget($ShopIDList[$z]["employee_id"], $mergeShop, $startPatternPre, $startPattern, $AppNotStampedShiftType);
                            // $totalHour = "00:00:00";
                            // foreach ($dtScheduleDay as $key => $value) {
                            //     //・Record件数 > 0 の場合は、労働時間を計算する。
                            //     //・TotalType = 'app'の場合は以下の時間を取得する。  'temp_shift'の場合は希望シフト時間を取得する。0.11.0b
                            //     //DayBeforeStartShiftTime							←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_start ELSE [`work`.schedules].start END
                            //     $DayBeforeStartShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //     //DayBeforeBreak									←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_break_times ELSE [`work`.schedules].break_times END
                            //     $DayBeforeBreak = $this->isTempShift($value->type) ?  $value->update_break_times : $value->break;
                            //     //DayBeforeEndUserTime								←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_end ELSE [`work`.schedules].end END
                            //     $DayBeforeEndShiftTime = $this->isTempShift($value->type) ?  $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                            //     // ・Record件数 > 0 の場合は、シフト時間を計算する。
                            //     // 0, 1件しか取得されない想定だが、複数取得出来た場合は複数加算する。
                            //     // 計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            //     $start1 = $DayBeforeStartShiftTime;
                            //     $end1   = $startPattern . " 00:00:00";
                            //     $start2 = $end1;
                            //     $end2   = $DayBeforeEndShiftTime;
                            //     $break  = $DayBeforeBreak;
                            //     //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            //     $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //     //集計項目
                            //     $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                            // }
                            // //PatternPast[]	 ←	PatternPast[] + 計算した労働時間
                            // $PatternPast[$i]["WorkHour"] = $this->summationTime($PatternPast[$i]["WorkHour"], $totalHour);

                        } else if (isset($ShopIDList[$z]["FirstClockIn"]) && !is_null($ShopIDList[$z]["FirstClockIn"])) {
                            //・上記以外の場合 ( ShopIDList[].FirstClockIn != null の場合)
                            //・対象期間に最初の打刻日が含まれる場合は最初の打刻日の1日前まで集計する。（PatternPast[] の開始日 <= ShopIDList[].FirstClockInのDate - 1Day <= CurrentDate - 1Day の場合）
                            $FirstClockInPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $ShopIDList[$z]["FirstClockIn"] )));
                            $FirstClockIn = date( 'Y-m-d', strtotime ($ShopIDList[$z]["FirstClockIn"]));
                            // $dateStartPattern = date( 'Y-m-d', strtotime($PatternPast[$i]["start"]));
                            if (($startPattern <= $FirstClockInPre) && ($FirstClockInPre <= $datePre)) {
                                // $StartShift = date( 'Y-m-d', strtotime($PatternPast[$i]["start"]));
                                // $EndShift = $FirstClockInPre;
                                // $dtScheduleShift = $ScheduleTbl->getScheduleShiftPattern($ShopIDList[$z]["employee_id"], $mergeShop, $StartShift, $EndShift, $AppNotStampedShiftType);
                                // $totalHour = "00:00:00";
                                // $ShiftHour = "00:00:00";
                                // foreach ($dtScheduleShift as $key => $value) {
                                //     //以下の時間を取得する。  'temp_shift'の場合は希望シフト時間を取得する。0.11.0b
                                //     //StartShiftTime			            ←		IF(  type = 'temp_shift', [`work`.schedules].update_start, [`work`.schedules].start )
                                //     $StartShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //     //Break						            ←		IF ( type = 'temp_shift', [`work`.schedules].update_break_times, [`work`.schedules].break_times )
                                //     $Break = $this->isTempShift($value->type) ? $value->update_break_times : $value->break;
                                //     //EndShiftTime						    ←		IF ( type = 'temp_shift' , [`work`.schedules].update_end, [`work`.schedules].end )
                                //     $EndShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //     if ( $EndShiftTime > ($FirstClockIn . " 00:00:00")) {
                                //         $hour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockIn . " 00:00:00", $Break);
                                //     } else {
                                //         $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                //     }
                                //     $ShiftHour = $this->summationTime($ShiftHour, $hour);
                                // }
                                // //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)
                                // $PatternPast[$i]["WorkHour"]  = $this->summationTime($PatternPast[$i]["WorkHour"], $ShiftHour);

                                // //・Pattern1-6の対象期間開始日の前日からのシフト時間
                                // $StartShiftPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $StartShift )));
                                // $dtSchedulePre = $ScheduleTbl->getScheduleALLShiftTarget($ShopIDList[$z]["employee_id"], $mergeShop, $StartShiftPre, $StartShift, $AppNotStampedShiftType);
                                // $totalHour = "00:00:00";
                                // foreach ($dtSchedulePre as $key => $value) {
                                //     //・TotalType = 'app'の場合は以下の時間を取得する。  'temp_shift'の場合は希望シフト時間を取得する。0.11.0b
                                //     //DayBeforeStartShiftTime							←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_start ELSE [`work`.schedules].start END
                                //     $DayBeforeStartShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //     //DayBeforeBreak									←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_break_times ELSE [`work`.schedules].break_times END
                                //     $DayBeforeBreak = $this->isTempShift($value->type) ?  $value->update_break_times : $value->break;
                                //     //DayBeforeEndUserTime								←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_end ELSE [`work`.schedules].end END
                                //     $DayBeforeEndShiftTime = $this->isTempShift($value->type) ?  $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //     // ・Record件数 > 0 の場合は、シフト時間を計算する。
                                //     // 0, 1件しか取得されない想定だが、複数取得出来た場合は複数加算する。
                                //     // 計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //     $start1 = $DayBeforeStartShiftTime;
                                //     $end1   = $StartShift . " 00:00:00";
                                //     $start2 = $end1;
                                //     $end2   = $DayBeforeEndShiftTime;
                                //     $break  = $DayBeforeBreak;
                                //     //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //     $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //     //集計項目
                                //     $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                // }
                                // //PatternPast[]	←	PatternPast[] + 計算した労働時間
                                // $PatternPast[$i]["WorkHour"] = $this->summationTime($PatternPast[$i]["WorkHour"], $totalHour);
                            }
                            //・Pattern1-6の最初の打刻日で、最初の打刻日の前日から打刻日時以前の確定シフト時間を集計する。(PatternPast[] の開始日 <= ShopIDList[].FirstClockInのDate <= CurrentDate - 1Day の場合)
                            //ex. 最初の打刻 = 04/01 13:00の場合、04/01 00:00 ~ 04/01 13:00 までを集計する。
                            if (($startPattern <= $FirstClockIn) && ($FirstClockIn <= $datePre)) {
                                // $totalHour = "00:00:00";
                                // //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                                // $dtSchedule = $ScheduleTbl->getScheduleALLShiftTarget($ShopIDList[$z]["employee_id"], $mergeShop, $FirstClockInPre, $FirstClockIn, $AppNotStampedShiftType);
                                // foreach ($dtSchedule as $key => $value) {
                                //     //・TotalType = 'app'の場合は以下の時間を取得する。  'temp_shift'の場合は希望シフト時間を取得する。0.11.0b
                                //     //DayBeforeStartShiftTime							←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_start ELSE [`work`.schedules].start END
                                //     $DayBeforeStartShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //     //DayBeforeBreak									←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_break_times ELSE [`work`.schedules].break_times END
                                //     $DayBeforeBreak = $this->isTempShift($value->type) ?  $value->update_break_times : $value->break;
                                //     //DayBeforeEndUserTime								←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_end ELSE [`work`.schedules].end END
                                //     $DayBeforeEndShiftTime = $this->isTempShift($value->type) ?  $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //     // ・Record件数 > 0 の場合は、確定シフト時間を計算する。
                                //     // 0, 1件しか取得されない想定だが、複数取得出来た場合は複数加算する。
                                //     // 計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //     $start1 = $DayBeforeStartShiftTime;
                                //     $end1   = $FirstClockIn . " 00:00:00";
                                //     $start2 = $end1;
                                //     $end2   = $DayBeforeEndShiftTime;
                                //     $break  = $DayBeforeBreak;
                                //     //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //     $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);

                                //     //最初の打刻が、シフト時間内の場合、シフト時間から、その差分を引く。
                                //     //< DayBeforeEndShiftTime <= ShopIDList[].FirstClockIn の場合 >
                                //     if ( $DayBeforeEndShiftTime <= $ShopIDList[$z]["FirstClockIn"]) {
                                //         //PatternPast[]		←	PatternPast[] + 当日労働時間の計算結果
                                //         $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                //     } else {
                                //         //< DayBeforeEndShiftTime > ShopIDList[].FirstClockIn の場合 >
                                //         //PatternPast[] + 当日労働時間の計算結果 -  ( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
                                //         //PatternPast[] +  計算した確定シフト時間 -  ( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
							    //         //                     ↑マイナス時間になる場合は 0時間 にする。
                                //         $hourstart = $this->summationTime($totalHour, $data["WorkHour"]);
                                //         $ShiftTime = Chronos::parse($DayBeforeEndShiftTime);
                                //         $FirstClock = Chronos::parse($ShopIDList[$z]["FirstClockIn"]);
                                //         //( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
                                //         $diff = $FirstClock->diff($ShiftTime);
                                //         $hourend = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                //         if ($hourstart > $hourend) $totalHour = $this->subtractionTime($hourstart, $hourend);
                                //     }
                                // }
                                // //PatternPast[]	←	PatternPast[] + 計算した労働時間
                                // $PatternPast[$i]["WorkHour"] = $this->summationTime($PatternPast[$i]["WorkHour"], $totalHour);

                                // //・FirstClockInの日で最初の打刻時間以前の確定シフト時間を計算する。
                                // $dtSchedule = $ScheduleTbl->getScheduleALLShiftTimePattern($ShopIDList[$z]["employee_id"], $mergeShop, $FirstClockIn . " 00:00:00", $ShopIDList[$z]["FirstClockIn"], $AppNotStampedShiftType);
                                // $ShiftHour = "00:00:00";
                                // foreach ($dtSchedule as $key => $value) {
                                //     //以下の時間を取得する。  'temp_shift'の場合は希望シフト時間を取得する。
                                //     if ($value->type === 'temp_shift' ) {
                                //         $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //         $ShiftBreak = $value->update_break;
                                //         $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //     } else {
                                //         $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //         $ShiftBreak = $value->break;
                                //         $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //     }

                                //     if ($EndShiftTime <= $ShopIDList[$z]["FirstClockIn"]) {
                                //         $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                //     } else {
                                //         // ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合
                                //         $StartShiftTime = Chronos::parse($StartShiftTime);
                                //         $FirstClock = Chronos::parse($ShopIDList[$z]["FirstClockIn"]);
                                //         $diff = $FirstClock->diff($StartShiftTime);
                                //         $time1 = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                //         $time2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                //         //<  ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合>
                                //         if ( $time1 >= $time2 ) {
                                //             //最初の打刻以前の労働時間が予定シフト時間以上の場合、休憩時間は取得済みとして計算する。
                                //             $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $ShopIDList[$z]["FirstClockIn"], $ShiftBreak);
                                //         } else {
                                //             $ShiftHour = $time1;
                                //         }
                                //     }
                                // }
                                // //PatternPast[]	←	PatternPast[] + 計算した労働時間
                                // $PatternPast[$i]["WorkHour"] = $this->summationTime($PatternPast[$i]["WorkHour"], $ShiftHour);
                            }
                        }
                    }
                }

                //・未連携店舗のシフト時間
                //未連携店舗の場合、シフト時間から集計する。
                // ・Pattern1-6（-6日から-1日までのPattern）分を取得する。
                // PatternPast[0]	From CurrentDate - 6Day  To CurrentDate - 1Day までの労働時間を設定する。	※長期休暇日により対象期間が変わる
                // PatternPast[1]	From CurrentDate - 5Day  To CurrentDate - 1Day までの労働時間を設定する。	※長期休暇日により対象期間が変わる
                // PatternPast[2]	From CurrentDate - 4Day  To CurrentDate - 1Day までの労働時間を設定する。	※長期休暇日により対象期間が変わる
                // PatternPast[3]	From CurrentDate - 3Day  To CurrentDate - 1Day までの労働時間を設定する。	※長期休暇日により対象期間が変わる
                // PatternPast[4]	From CurrentDate - 2Day  To CurrentDate - 1Day までの労働時間を設定する。	※長期休暇日により対象期間が変わる
                // PatternPast[5]	From CurrentDate - 1Day  To CurrentDate - 1Day までの労働時間を設定する。	※長期休暇日により対象期間が変わる
                //・対象期間開始日から、当日-1日までの労働時間
                //長期休暇が存在するため、28CheckStartDateまたは28CheckEndDate が Pattern1-6 の期間と一致しない場合があるため、長期休暇日を集計しないように注意すること。
                $dtSch = $ScheduleTbl->getWorkingHourNow($userId, $startPattern, $CurrentDate, $isCheckDesignation);
                $total = "00:00:00";
                foreach ($dtSch as $key => $value) {
                    //StartUserShiftTime				←		[`work`.schedules].start
                    $StartUserShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                    //Break						        ←		[`work`.schedules].break_times
                    $Break = $value["break_times"];
                    //EndUserShiftTime					←		[`work`.schedules].end
                    $EndUserShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                    //UserShiftHour						←		IF(EndUserShiftTime > CurrentDate + ' 00:00:00', CurrentDate + ' 00:00:00',  EndUserShiftTime) - StartUserShiftTime - Break
					//                                          WorkHour が、マイナス時間になる場合は 0:00 にする。
                    if ($EndUserShiftTime > $CurrentDate . " 00:00:00") {
                        $UserShiftHour = $this->calWorkTimeToBreak($StartUserShiftTime, $CurrentDate . " 00:00:00", $Break);
                    } else {
                        $UserShiftHour = $this->calWorkTimeToBreak($StartUserShiftTime, $EndUserShiftTime, $Break);
                    }
                    $total = $this->summationTime($total, $UserShiftHour);
                }
                //PatternPast[]	←	PatternPast[] + SUM(UserShiftHour)
                $PatternPast[$i]["WorkHour"]  = $this->summationTime($PatternPast[$i]["WorkHour"], $total);

                $startPatternPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $PatternPast[$i]["start"] )));
                //・Pattern1-6の対象期間開始日の前日からのシフト時間
                $dtSch = $ScheduleTbl->getWorkingHourStartEnd($userId, $startPatternPre, $startPattern, $isCheckDesignation);
                $totalHour = "00:00:00";
                foreach ($dtSch as $key => $value) {
                    //DayBeforeStartUserShiftTime						←	[`work`.schedules].start
                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                    //DayBeforeBreak									←	[`work`.schedules].break_times
                    $DayBeforeBreak = $value["break_times"];
                    //DayBeforeEndUserShiftTime							←	[`work`.schedules].end
                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                    // ・Record件数 > 0 の場合は、シフト時間を計算する。
                    // 0, 1件しか取得されない想定だが、複数取得出来た場合は複数加算する。
                    // 計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                    $start1 = $DayBeforeStartShiftTime;
                    $end1   = $startPattern . " 00:00:00";
                    $start2 = $end1;
                    $end2   = $DayBeforeEndShiftTime;
                    $break  = $DayBeforeBreak;
                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                    //集計項目
                    $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                }
                //PatternPast[]		←	PatternPast[] + 計算した労働時間
                $PatternPast[$i]["WorkHour"] = $this->summationTime($PatternPast[$i]["WorkHour"], $totalHour);
            }
        }
        //----3---・未来のシフト時間
        // PatternSchedule[1]		From CurrentDate +1Day  To CurrentDate + 1Day までのシフト時間を設定する。		※長期休暇日により対象期間が変わる
        // PatternSchedule[2]		From CurrentDate +1Day  To CurrentDate + 2Day までのシフト時間を設定する。		※長期休暇日により対象期間が変わる
        // PatternSchedule[3]		From CurrentDate +1Day  To CurrentDate + 3Day までのシフト時間を設定する。		※長期休暇日により対象期間が変わる
        // PatternSchedule[4]		From CurrentDate +1Day  To CurrentDate + 4Day までのシフト時間を設定する。		※長期休暇日により対象期間が変わる
        // PatternSchedule[5]		From CurrentDate +1Day  To CurrentDate + 5Day までのシフト時間を設定する。		※長期休暇日により対象期間が変わる
        // PatternSchedule[6]		From CurrentDate +1Day  To CurrentDate + 6Day までのシフト時間を設定する。		※長期休暇日により対象期間が変わる
        // ・ UserEmployIDList の件数 = 0 の場合は「・未連携店舗のシフト時間」を実施する。 CALL $ScheduleTbl->getWorkingHourNow
        $PatternSchedule = [];
        //---------------log start---------------------
        $this->writeLog28h('UserController', 'CalculateWorkTime28Hour', '28 hour limit - 未来のシフト時間', '', $CurrentDate, '');
        //---------------log end------------------------
        for ($i=0; $i < 6; $i++) {
            //・連携店舗の労働時間
            //・Pattern1-6（-6日から-1日までのPattern）分を取得する。
            $num = $i + 1;
            $end = date( 'Y-m-d 00:00:00', strtotime( $num .' day' , strtotime ( $CurrentDate )));
            if ($_28CheckEndDate . " 00:00:00" < $end) $end = $_28CheckEndDate . " 00:00:00"; //date( 'Y-m-d 00:00:00', strtotime('1 day' , strtotime ( $_28CheckEndDate )));
            $arr = [
                "start" => date( 'Y-m-d 00:00:00', strtotime('1 day' , strtotime ( $CurrentDate ))),
                "end" => $end
            ];
            array_push($PatternSchedule, $arr);
            $PatternSchedule[$i]["WorkHour"] = "00:00:00";
            //・連携店舗の確定シフト時間
            //・Pattern2-7（+1日から+6日までのPattern）分を取得する。
            $StartShift	= date( 'Y-m-d', strtotime($PatternSchedule[$i]["start"]));
            $EndShift	= date( 'Y-m-d', strtotime($PatternSchedule[$i]["end"]));
            $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));

            if ( $StartShift <= $_28CheckEndDate) {
                // //PatternSchedule[]の開始日 <  28CheckEndDate の場合のみ集計処理を行う。
                if (sizeof($UserEmployIDList) > 0) {
                    $dtSch = $ScheduleTbl->getScheduleShiftFuture($UserEmployIDList, $mergeShopID, $StartShift, $EndShift, $SearchShiftType, $TotalType);
                    $total = "00:00:00";
                    foreach ($dtSch as $key => $value) {
                        if($TotalType =='app'){
                            //・TotalType = 'app'の場合は以下の時間を取得する。  'temp_shift'の場合は希望シフト時間を取得する。
                            //StartShiftTime			            ←		IF(  type = 'temp_shift', [`work`.schedules].update_start, [`work`.schedules].start )
                            $StartShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //Break						            ←		IF ( type = 'temp_shift', [`work`.schedules].update_break_times, [`work`.schedules].break_times )
                            $Break = $this->isTempShift($value->type) ? $value->update_break_times : $value->break;
                            //EndShiftTime						    ←		IF ( type = 'temp_shift' , [`work`.schedules].update_end, [`work`.schedules].end )
                            $EndShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                        }else{
                            //・TotalType = 'wa'の場合は以下の時間を取得する。
                            //StartShiftTime						←		[`work`.schedules].start
                            $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //Break						            ←		[`work`.schedules].break_times
                            $Break = $value->break;
                            //EndShiftTime						    ←		[`work`.schedules].end
                            $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                        }
                        $EndShiftNext = date( 'Y-m-d', strtotime('1 day', strtotime($EndShift)));
                        //IF(EndShiftTime > EndShift+1day + ' 00:00:00', EndShift+1day + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                        if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                            $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                        } else {
                            $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                        }
                        $total =  $this->summationTime($total, $ShiftHour);
                    }
                    //PatternSchedule[]		←		SUM(ShiftHour)
                    $PatternSchedule[$i]["WorkHour"] = $this->summationTime($PatternSchedule[$i]["WorkHour"], $total);

                    //・対象期間開始日の前日からのシフト時間
                    $dtSch = $ScheduleTbl->getScheduleShiftStartEndFuture($UserEmployIDList, $mergeShopID, $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                    $total = "00:00:00";
                    foreach ($dtSch as $key => $value) {
                        if($TotalType =='app'){
                            //・TotalType = 'app'の場合は以下の時間を取得する。  'temp_shift'の場合は希望シフト時間を取得する。
                            //DayBeforeStartShiftTime							←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_start ELSE [`work`.schedules].start END
                            $DayBeforeStartShiftTime = $this->isTempShift($value->type) ? $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //DayBeforeBreak									←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_break_times ELSE [`work`.schedules].break_times END
                            $DayBeforeBreak = $this->isTempShift($value->type) ?  $value->update_break_times : $value->break;
                            //DayBeforeEndUserTime								←	CASE type WHEN 'temp_shift' THEN [`work`.schedules].update_end ELSE [`work`.schedules].end END
                            $DayBeforeEndShiftTime = $this->isTempShift($value->type) ?  $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00') : $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                        }else{
                            //・TotalType = 'wa'の場合は以下の時間を取得する。
                            //DayBeforeStartShiftTime							←	[`work`.schedules].start
                            $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //DayBeforeBreak									←	[`work`.schedules].break_times
                            $DayBeforeBreak = $value->break;
                            //DayBeforeEndUserTime								←	[`work`.schedules].end
                            $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                        }
                        $start1 = $DayBeforeStartShiftTime;
                        $end1   = $StartShift . " 00:00:00";
                        $start2 = $end1;
                        $end2   = $DayBeforeEndShiftTime;
                        $break  = $DayBeforeBreak;
                        //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                        $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                        //集計項目
                        $total = $this->summationTime($total, $data["WorkHour"]);
                    }
                    //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                    $PatternSchedule[$i]["WorkHour"] = $this->summationTime($PatternSchedule[$i]["WorkHour"], $total);
                }
                // ・未連携店舗のシフト時間
                //未連携店舗の場合、シフト時間から集計する。
                $dtSch = $ScheduleTbl->getWorkingHourNow($userId, $StartShift, $EndShift, $isCheckDesignation);
                $total = "00:00:00";
                foreach ($dtSch as $key => $value) {
                    $StartUserShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                    $Break = $value["break_times"];
                    $EndUserShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                    $EndShiftNext = date( 'Y-m-d', strtotime('+1 day', strtotime($EndShift)));
                    //IF(EndUserShiftTime > EndShift + ' 00:00:00', EndShift + ' 00:00:00',  EndUserShiftTime) - StartUserShiftTime - Break
                    if ($EndUserShiftTime > $EndShiftNext . " 00:00:00") {
                        $UserShiftHour = $this->calWorkTimeToBreak($StartUserShiftTime, $EndShiftNext . " 00:00:00", $Break);
                    } else {
                        $UserShiftHour = $this->calWorkTimeToBreak($StartUserShiftTime, $EndUserShiftTime, $Break);
                    }
                    $total = $this->summationTime($total, $UserShiftHour);
                }
                //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                $PatternSchedule[$i]["WorkHour"] = $this->summationTime($PatternSchedule[$i]["WorkHour"], $total);

                //・対象期間開始日の前日からのシフト時間
                $dtSch = $ScheduleTbl->getWorkingHourStartEnd($userId, $StartShiftPre, $StartShift, $isCheckDesignation);
                $total = "00:00:00";
                foreach ($dtSch as $key => $value) {
                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                    $DayBeforeBreak = $value["break_times"];
                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');

                    $start1 = $DayBeforeStartShiftTime;
                    $end1   = $StartShift . " 00:00:00";
                    $start2 = $end1;
                    $end2   = $DayBeforeEndShiftTime;
                    $break  = $DayBeforeBreak;
                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                    //集計項目
                    $total = $this->summationTime($total, $data["WorkHour"]);
                }
                //PatternPast[]		←	PatternPast[] + 計算した労働時間
                $PatternSchedule[$i]["WorkHour"] = $this->summationTime($PatternSchedule[$i]["WorkHour"], $total);
            }
        }

        //----4---・最大労働時間を取得する。
        //・過去、当日、未来の労働時間をPattern別に合算する。
        $Pattern = [];
        $MaxWorkHour = "00:00:00";
        //---------------log start---------------------
        $this->writeLog28h('UserController', 'CalculateWorkTime28Hour', '28 hour limit - 最大労働時間を取得する。', '', $CurrentDate, '');
        //---------------log end------------------------
        for ($i=0; $i < 7; $i++) {
            $y = $i - 1;
            if ( $i == 0) {
                $Pattern[$i] = $this->summationTime($PatternPast[$i]["WorkHour"], $TodayWorkHour);
            } else if ($i > 5) {
                $Pattern[$i] = $this->summationTime($PatternSchedule[$y]["WorkHour"], $TodayWorkHour);
            } else {
                $hour = $this->summationTime($PatternPast[$i]["WorkHour"], $TodayWorkHour);
                $hour = $this->summationTime($hour, $PatternSchedule[$y]["WorkHour"]);
                $Pattern[$i] = $hour;
            }
            //・Pattern1から7まで最大の労働時間を取得する。
	        //MaxWorkHour	←	Max (Pattern[])
            if ($this->parseHourToSeconds($MaxWorkHour) < $this->parseHourToSeconds($Pattern[$i])) $MaxWorkHour = $Pattern[$i];
        }
        $rs["MaxWorkHour"] = $MaxWorkHour;

        return  $rs;
    }



    public function CalculateShiftWorkTime28Hour ($UserEmployIDList, $mergeShopID,
                                        $LatestWorkID, $LatestWorkStartTime, $LatestWorkEndTime,
                                        $LatestStartBreakTime, $LatestBreak, $CurrentDate, $CurrentDateTime,
                                        $ShopIDList,$_28CheckStartDate, $_28CheckEndDate, $TargetDate, $LatestWorkShopID,
                                        $user_Id, $isCheckDesignation, $SearchShiftType, $TotalType) {

        $rs["TodayWorkHour"] = '00:00:00';
        $rs["TodayShiftHour"] = '00:00:00';
        $rs["PreviousDayUsedBreakTime"] = '00:00:00';
        $rs["ClockIn"] = '';
        $rs["TargetDayWorkHour"] = "00:00:00";
        $rs["RemainingTimeLimit"] = "00:00:00";
        $rs["FromDateMax"] = "00:00:00";
        $rs["ToDateMax"] = "00:00:00";
        $TodayWorkHour = "00:00:00";
        $AttendanceTbl = $this->getTableLocator()->get('Attendance');
        $ScheduleTbl = $this->getTableLocator()->get('Schedule');
        $LatestWorkStart = null;
        $LatestWorkEnd = null;
        // $auth = $this->getAuth();
        //LoginUserのuser_id
        $userId = $user_Id;
        //・前日からの労働時間を計算する。
        if (!is_null($LatestWorkStartTime)) {
            //LatestWorkStartTimeのDate
            $LatestWorkStart = date('Y-m-d', strtotime($LatestWorkStartTime));
        }
        if (!is_null($LatestWorkEndTime)) {
            //LatestWorkEndTimeのDate
            $LatestWorkEnd = date('Y-m-d', strtotime($LatestWorkEndTime));
        }
        $TotalWorkHour = "00:00:00";
        $preCurrentDate= date('Y-m-d' , strtotime('-1 day', strtotime ($CurrentDate)));
        $PatternPast = [];
        $PatternSchedule = [];
        $PatternUser =[];
        for ($j=0; $j < 7; $j++) {
            //・Pattern1-7（-6日から+6日までのPattern）分を取得する。
            $num = 6 - $j;
            //Pattern user
            $start = date( 'Y-m-d 00:00:00', strtotime('-'. (int) $num .' day' , strtotime ( $TargetDate)));
            $end = date( 'Y-m-d 00:00:00', strtotime('+ '.$j.' day' , strtotime ( $TargetDate )));

            $startUser = ( $start < $_28CheckStartDate . " 00:00:00" ) ?  $_28CheckStartDate  . " 00:00:00" : $start;
            $endUser = ($_28CheckEndDate . " 00:00:00"  < $end) ? $_28CheckEndDate  . " 00:00:00" : $end;
            $arrUser = [
                "start" => $startUser,
                "end" => $endUser
            ];

            // $startPast= ($start >= $CurrentDate . " 00:00:00" ) ? date('Y-m-d 00:00:00' , strtotime('+1 day', strtotime ($CurrentDate))) : $start;
            $startPast = ($start < $_28CheckStartDate . " 00:00:00" ) ? $_28CheckStartDate  . " 00:00:00"  : $start;
            $endPast = ($end >= $CurrentDate . " 00:00:00" ) ? date('Y-m-d 00:00:00' , strtotime('-1 day', strtotime ($CurrentDate))) : $end;
            $endPast = ($_28CheckEndDate . " 00:00:00"  < $endPast) ? $_28CheckEndDate  . " 00:00:00"  : $endPast;
            $arrPast = [
                "start" => $startPast,
                "end" => $endPast
            ];

            $startSchedule = ( $start <= $CurrentDate . " 00:00:00" ) ? date('Y-m-d 00:00:00' , strtotime('+1 day', strtotime ($CurrentDate))) : $start;
            $startSchedule = ($startPast < $_28CheckStartDate . " 00:00:00" ) ? $_28CheckStartDate  . " 00:00:00"  : $startSchedule;
            // $endSchedule = ( $end <= $CurrentDate . " 00:00:00" ) ? date('Y-m-d 00:00:00' , strtotime('+1 day', strtotime ($CurrentDate))) : $end;
            $endSchedule = ($_28CheckEndDate . " 00:00:00"  < $end) ? $_28CheckEndDate  . " 00:00:00"  : $end;
            $arrSchedule = [
                "start" => $startSchedule,
                "end" => $endSchedule,
                "flg_schedule" => ($startSchedule > $endSchedule) ? false : true
            ];

            array_push($PatternPast, $arrPast);
            array_push($PatternSchedule, $arrSchedule);
            array_push($PatternUser, $arrUser);
            //長期休暇により、28CheckStartDate と Pattern1-7 が一致しない場合、該当するPatternから実施する。
            $PatternPast[$j]["WorkHour"] = "00:00:00";
            $PatternSchedule[$j]["WorkHour"] = "00:00:00";
            $PatternUser[$j]["WorkHour"] = "00:00:00";
        }
        //---------------log start---------------------
        $this->writeLog28h('UserController', 'CalculateShiftWorkTime28Hour', '28 hour limit - ShopIDList のshop_id単位で以下の処理をLoopする。', '', $CurrentDate, '');

        if (sizeof($UserEmployIDList) !== 0) {
            //---------------log end------------------------
            //ShopIDList のshop_id単位で以下の処理をLoopする。
            for ($i=0; $i < sizeof($ShopIDList); $i++) {
                $FirstClockIn = $ShopIDList[$i]["FirstClockIn"];
                //・最初の打刻が無い場合 ( FirstClockIn = null の場合 )
                //.計算方法は「・未来の労働時間を計算する。」と同じ、確定シフトから集計する。
                if(is_null($FirstClockIn)){
                    //・チェック対象期間が現在日よりあとの場合 ( 28CheckStartDate > CurrentDate の場合)
                    for ($j=0; $j < 7; $j++) {
                        $num = 6 - $j;
                        $start = date( 'Y-m-d 00:00:00', strtotime('-'. (int) $num .' day' , strtotime ( $TargetDate)));
                        $end = date( 'Y-m-d 00:00:00', strtotime('+ '.$j.' day' , strtotime ( $TargetDate )));

                        $startPattern = ( $start < $_28CheckStartDate . " 00:00:00" ) ?  $_28CheckStartDate  . " 00:00:00" : $start;
                        $endPattern = ($_28CheckEndDate . " 00:00:00"  < $end) ? $_28CheckEndDate  . " 00:00:00" : $end;

                        // if (!$PatternSchedule[$j]['flg_schedule']) continue;
                        $StartShift	= date( 'Y-m-d', strtotime($startPattern));
                        $EndShift	= date( 'Y-m-d', strtotime($endPattern));
                        //Delete v.0.12.0
                        //・過去の労働時間を計算する。
                        //・チェック対象期間が現在日より前の場合 ( 28CheckEndDate < CurrentDate の場合 )
                        // if ($_28CheckEndDate < $CurrentDate) {
                        //     $dtSch = $ScheduleTbl->getALLShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $AppNotStampedShiftType);
                        //     $total = "00:00:00";
                        //     foreach ($dtSch as $key => $value) {
                        //         if ($value["type"] === 'temp_shift') {
                        //             $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                        //             $Break = $value["update_break"];
                        //             $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                        //         } else {
                        //             $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                        //             $Break = $value["break"];
                        //             $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                        //         }
                        //         $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                        //         //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                        //         if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                        //             $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                        //         } else {
                        //             $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                        //         }
                        //         $total = $this->summationTime($total, $ShiftHour);
                        //     }
                        //     //PatternSchedule[]		←		SUM(ShiftHour)
                        //     $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                        //     $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                        //     //・対象期間開始日の前日からの確定シフト時間
                        //     $dtSch = $ScheduleTbl->getALLShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $AppNotStampedShiftType);
                        //     $total = "00:00:00";
                        //     foreach ($dtSch as $key => $value) {
                        //         if ($value["type"] === 'temp_shift') {
                        //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                        //             $DayBeforeBreak = $value["update_break"];
                        //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                        //         } else {
                        //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                        //             $DayBeforeBreak = $value["break"];
                        //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                        //         }
                        //         $start1 = $DayBeforeStartShiftTime;
                        //         $end1   = $StartShift . " 00:00:00";
                        //         $start2 = $end1;
                        //         $end2   = $DayBeforeEndShiftTime;
                        //         $break  = $DayBeforeBreak;
                        //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                        //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                        //         //集計項目
                        //         $total = $this->summationTime($total, $data["WorkHour"]);
                        //     }
                        //     //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                        //     $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                        // }
                        //・未来の労働時間を計算する。
                        //・チェック対象期間が現在日よりあとの場合 ( 28CheckStartDate > CurrentDate の場合)
                        if ($_28CheckStartDate > $CurrentDate) {
                            if (!$PatternSchedule[$j]['flg_schedule']) continue;

                            $dtSch = $ScheduleTbl->getShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $Break = $value["update_break"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $Break = $value["break"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }

                                $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                                //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                                if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                                } else {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                }
                                $total = $this->summationTime($total, $ShiftHour);
                            }
                            //PatternSchedule[]		←		SUM(ShiftHour)
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                            $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                            //・対象期間開始日の前日からの確定シフト時間
                            $dtSch = $ScheduleTbl->getShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $DayBeforeBreak = $value["update_break"];
                                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $DayBeforeBreak = $value["break"];
                                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }

                                $start1 = $DayBeforeStartShiftTime;
                                $end1   = $StartShift . " 00:00:00";
                                $start2 = $end1;
                                $end2   = $DayBeforeEndShiftTime;
                                $break  = $DayBeforeBreak;
                                //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //集計項目
                                $total = $this->summationTime($total, $data["WorkHour"]);
                            }
                            //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                        }
                        //・過去+未来の労働時間を計算する。
                        // ・チェック対象期間内に現在日が存在する場合 ( 28CheckStartDate <= CurrentDate <= 28CheckEndDate の場合)
                        if($_28CheckStartDate <= $CurrentDate && $CurrentDate <= $_28CheckEndDate) {
                            $StartShiftDatePattern	= date( 'Y-m-d', strtotime($startPattern));
                            $EndShiftDatePattern	= date( 'Y-m-d', strtotime($endPattern));
                            //・Pattern1-7の対象期間開始日から、CurrentDateまでのシフト時間を集計する。 ( PatternSchedule[] の開始日 <=  CurrentDate <= PatternSchedule[] の終了日 の場合)
                            if ($StartShiftDatePattern <= $CurrentDate && $CurrentDate <= $EndShiftDatePattern) {
                                //Delete v.0.12.0
                                // //・開始日から、CurrentDateTime までのシフト時間を集計する。
                                // $StartShift	= date( 'Y-m-d', strtotime($startPattern));
                                // $EndShift	= date( 'Y-m-d', strtotime($CurrentDate));
                                // $dtSch = $ScheduleTbl->getShiftPastNolink($ShopIDList[$i], $StartShift, $EndShift, $CurrentDateTime, $AppNotStampedShiftType);
                                // $total = "00:00:00";
                                // foreach ($dtSch as $key => $value) {
                                //     if ($value["type"] === 'temp_shift') {
                                //         $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                //         $Break = $value["update_break_times"];
                                //         $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                //     } else {
                                //         $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                //         $Break = $value["break_times"];
                                //         $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                //     }

                                //     $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                //     $total = $this->summationTime($total, $ShiftHour);
                                // }
                                // //PatternSchedule[]		←		SUM(ShiftHour)
                                // $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                                // //・対象期間開始日の前日からの確定シフト時間
                                // $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                                // $dtSch = $ScheduleTbl->getALLShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $AppNotStampedShiftType);
                                // $total = "00:00:00";
                                // foreach ($dtSch as $key => $value) {
                                //     if ($value["type"] === 'temp_shift') {
                                //         $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                //         $DayBeforeBreak = $value["update_break"];
                                //         $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                //     } else {
                                //         $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                //         $DayBeforeBreak = $value["break"];
                                //         $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                //     }
                                //     $start1 = $DayBeforeStartShiftTime;
                                //     $end1   = $StartShift . " 00:00:00";
                                //     $start2 = $end1;
                                //     $end2   = $DayBeforeEndShiftTime;
                                //     $break  = $DayBeforeBreak;
                                //     //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //     $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //     //集計項目
                                //     $total = $this->summationTime($total, $data["WorkHour"]);
                                // }
                                // //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                                // $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                                //・ CurrentDateTime から、Pattern1-7の対象期間開始日 までのシフト時間を集計する。
                                $StartShift	= $preCurrentDate;
                                $EndShift	= date('Y-m-d', strtotime($endPattern));

                                $dtSch = $ScheduleTbl->getALLShiftPastNolink($ShopIDList[$i], $StartShift, $EndShift, $CurrentDateTime, $SearchShiftType, $TotalType);
                                $total = "00:00:00";
                                foreach ($dtSch as $key => $value) {
                                    if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                        $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                        $Break = $value["update_break_times"];
                                        $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                    } else {
                                        $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                        $Break = $value["break_times"];
                                        $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                    }
                                    // $typeShift = $value["type"];
                                    $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                                    $EndShiftTime = (  $EndShiftTime >= $EndShiftNext . " 00:00:00" ) ? $EndShiftNext . " 00:00:00" : $EndShiftTime;
                                    //< ShiftTypeが過去で取得するシフトTypeである場合 (ShiftType = AppNotStampedShiftType[] の場合) >
                                    // if ($typeShift === 'temp_shift' || $typeShift === 'req_shift') {
                                    //     $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                    // } else {
                                    //     if ( $StartShiftTime < $CurrentDateTime ) {
                                    //         //<  ( EndShiftTime - CurrentDateTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合>
                                    //         // ( EndShiftTime - CurrentDateTime )
                                    //         $time1 = Chronos::parse($EndShiftTime);
                                    //         $time2 = Chronos::parse($CurrentDateTime);
                                    //         $diff = $time1->diff($time2);
                                    //         $hour1 = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                    //         //( EndShiftTime - StartShiftTime - ShiftBreak )
                                    //         $hour2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                    //         if ($hour1 >= $hour2) {
                                    //             //最初の打刻後の残りの予定シフト時間が予定シフト時間以上の場合、休憩時間は取得済みとして計算する。
                                    //             // EndShiftTime - CurrentDateTime - ShiftBreak
                                    //             $ShiftHour = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, $Break);
                                    //         } else {
                                    //             //EndShiftTime - CurrentDateTime
                                    //             $ShiftHour = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                                    //         }
                                    //     } else {
                                    //         $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                    //     }
                                    // }
                                    //< StartShiftTime のDate = StartShift の場合（前日からのシフトの場合） >
                                    if ( date( 'Y-m-d', strtotime($StartShiftTime)) === $StartShift ) {
                                        //< (CurrentDateTime - StartShiftTime)の分 <= Break >
                                        $total1  = $this->calWorkTimeToBreak($StartShiftTime, $CurrentDateTime, 0);
                                        if ((int) $this->parseTimeToMin($total1) <= (int) $Break) {
                                            $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                        } else {
                                            $ShiftHour = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                                        }
                                    } else {
                                        //<  StartShiftTime < CurrentDateTime の場合 >
                                        if ($StartShiftTime < $CurrentDateTime) {
                                            //<  ( EndShiftTime - CurrentDateTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合>
                                            $total1  = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                                            $total2  = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                            if ($total1 >= $total2) {
                                                $ShiftHour = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, $Break);
                                            } else {
                                                $ShiftHour = $total1;
                                            }
                                        } else {
                                            $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                        }
                                    }
                                    $total = $this->summationTime($total, $ShiftHour);
                                }
                                //PatternSchedule[]		←		SUM(ShiftHour)
                                $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                            }
                            //・CurrentDate < PatternSchedule[] の開始日 の場合
                            if ($CurrentDate < $StartShiftDatePattern) {
                                $StartShift	= date( 'Y-m-d', strtotime($startPattern));
                                $EndShift	= date( 'Y-m-d', strtotime($endPattern));

                                $dtSch = $ScheduleTbl->getShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $SearchShiftType, $TotalType);
                                $total = "00:00:00";
                                foreach ($dtSch as $key => $value) {
                                    if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                        $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                        $Break = $value["update_break"];
                                        $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                    } else {
                                        $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                        $Break = $value["break"];
                                        $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                    }

                                    $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                                    // //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                                    if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                                        $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                                    } else {
                                        $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                    }
                                    $total = $this->summationTime($total, $ShiftHour);
                                }
                                //PatternSchedule[]		←		SUM(ShiftHour)
                                $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                                $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                                //・対象期間開始日の前日からの確定シフト時間
                                $dtSch = $ScheduleTbl->getShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                                $total = "00:00:00";
                                foreach ($dtSch as $key => $value) {
                                    if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                        $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                        $DayBeforeBreak = $value["update_break"];
                                        $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                    } else {
                                        $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                        $DayBeforeBreak = $value["break"];
                                        $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                    }
                                    $start1 = $DayBeforeStartShiftTime;
                                    $end1   = $StartShift . " 00:00:00";
                                    $start2 = $end1;
                                    $end2   = $DayBeforeEndShiftTime;
                                    $break  = $DayBeforeBreak;
                                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                    //集計項目
                                    $total = $this->summationTime($total, $data["WorkHour"]);
                                }
                                //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                                $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                            }
                            // Delete v.0.12.0
                            // //・PatternSchedule[] の終了日 < CurrentDate の場合
                            // if ($EndShiftDatePattern < $CurrentDate) {
                            //     $StartShift	= date( 'Y-m-d', strtotime($startPattern));
                            //     $EndShift	= date( 'Y-m-d', strtotime($endPattern));

                            //     $dtSch = $ScheduleTbl->getALLShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $AppNotStampedShiftType);
                            //     $total = "00:00:00";
                            //     foreach ($dtSch as $key => $value) {
                            //         if ($value["type"] === 'temp_shift') {
                            //             $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                            //             $Break = $value["update_break"];
                            //             $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                            //         } else {
                            //             $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                            //             $Break = $value["break"];
                            //             $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                            //         }
                            //         $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                            //         //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                            //         if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                            //             $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                            //         } else {
                            //             $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                            //         }
                            //         $total = $this->summationTime($total, $ShiftHour);
                            //     }
                            //     //PatternSchedule[]		←		SUM(ShiftHour)
                            //     $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                            //     $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                            //     //・対象期間開始日の前日からの確定シフト時間
                            //     $dtSch = $ScheduleTbl->getALLShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $AppNotStampedShiftType);
                            //     $total = "00:00:00";
                            //     foreach ($dtSch as $key => $value) {
                            //         if ($value["type"] === 'temp_shift') {
                            //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                            //             $DayBeforeBreak = $value["update_break"];
                            //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                            //         } else {
                            //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                            //             $DayBeforeBreak = $value["break"];
                            //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                            //         }
                            //         $start1 = $DayBeforeStartShiftTime;
                            //         $end1   = $StartShift . " 00:00:00";
                            //         $start2 = $end1;
                            //         $end2   = $DayBeforeEndShiftTime;
                            //         $break  = $DayBeforeBreak;
                            //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //         //集計項目
                            //         $total = $this->summationTime($total, $data["WorkHour"]);
                            //     }
                            //     //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                            //     $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                            // }
                        }
                    }
                }
                //・過去の労働時間を計算する。 ( FirstClockIn != null の場合 )
                else{
                    $FirstClockInDate = date('Y-m-d', strtotime($FirstClockIn));
                    // //・チェック対象期間が現在日より前の場合 ( 28CheckEndDate < CurrentDate AND FirstClockInのDate <= 28CheckEndDate の場合 )
                    // if($_28CheckEndDate < $CurrentDate && $FirstClockInDate <= $_28CheckEndDate){
                    //・チェック対象期間が現在日より前の場合 ( 28CheckEndDate < CurrentDate の場合 ) v.0.7.8
                    if($_28CheckEndDate < $CurrentDate){
                        //・連携店舗の労働時間を計算する。
                        for ($j=0; $j < 7; $j++) {
                            $StartShift	= date( 'Y-m-d', strtotime($PatternPast[$j]["start"]));
                            $EndShift	= date( 'Y-m-d', strtotime($PatternPast[$j]["end"]));
                            //・連携店舗の労働時間
                            //長期休暇が存在するため、28CheckStartDateまたは28CheckEndDate が Pattern1-6 の期間と一致しない場合があるため、長期休暇日を集計しないように注意すること。
                            $TotalWorkHour28h = "00:00:00";
                            $PatternPastEndNext = date( 'Y-m-d 00:00:00', strtotime('+1 day' , strtotime ( $PatternPast[$j]['end'] )));
                            $dtAtten = $AttendanceTbl->getShiftAttendance28h($ShopIDList[$i], $PatternPast[$j]);
                            foreach ($dtAtten as $key => $value) {
                                $StartWorkTime =  $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                // $dtBreak = $value["break_times"];
                                $Break = $value["break_times"];
                                $date = $this->checkNullFormatDate($value["date"], 'Y-m-d');
                                if ( $date === $preCurrentDate ) {
                                    $Break = (is_null($Break)) ? $LatestBreak : $Break;
                                }
                                $Break = (is_null($Break)) ? 0 : $Break;
                                // $EndWorkTime =  $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                $endTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                $EndWorkTime = (is_null($endTime)) ? $CurrentDateTime : $endTime ;

                                //IF(EndWorkTime > CurrentDate + ' 00:00:00', CurrentDate + ' 00:00:00',  EndWorkTime) - StartWorkTime - Break
                                if ($EndWorkTime > $PatternPastEndNext) {
                                    $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $PatternPastEndNext, $Break);
                                } else {
                                    $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $EndWorkTime, $Break);
                                }
                                //集計項目
                                $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $WorkHour);
                            }
                            //PatternPast[]	← SUM(WorkHour)
                            $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $TotalWorkHour28h);

                            //・Pattern1-7の対象期間開始日の前日からの労働時間
                            $arrTimePattern = [
                                "start" => $StartShift,
                                "end" => $EndShift
                            ];
                            $dtAttenPre = $AttendanceTbl->getShiftAttendancePreDay($ShopIDList[$i], $arrTimePattern);
                            $TotalWorkHour28h = "00:00:00";
                            foreach ($dtAttenPre as $key => $value) {
                                //・Record件数 > 0 の場合は、労働時間を計算する。
                                $DayBeforeStartWorkTime = $this->checkNullFormatDate($value->start,'Y-m-d H:i:00');
                                $DayBeforeStartBreak = $value->break;
                                $DayBeforeEndWorkTime = $this->checkNullFormatDate($value->end,'Y-m-d H:i:00');

                                $start1 = $DayBeforeStartWorkTime;
                                $end1   = $StartShift . " 00:00:00";
                                $start2 = $end1;
                                $end2   = $DayBeforeEndWorkTime;
                                $break  = $DayBeforeStartBreak;
                                //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //集計項目
                                $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $data["WorkHour"]);
                            }
                            //PatternPast[]	 ←	PatternPast[] + 計算した労働時間
                            $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $TotalWorkHour28h);
                            //・連携店舗の確定シフト時間を計算する。
                            //・PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日の場合の集計処理を行う。
                            if( $StartShift <= $FirstClockInDate && $FirstClockInDate <= $EndShift ){
                                //Pattern1-7（-6日から+6日までのPattern）分を取得する。
                                //PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日
                                //・対象期間に最初の打刻日が含まれる場合は最初の打刻日の1日前まで集計する。（ PatternPast[] の開始日 < FirstClockInのDate <= PatternPast[] の終了日 の場合）
                                $FirstClockInPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $FirstClockInDate )));
                                // Delete v.0.12.0
                                // if( $StartShift < $FirstClockInDate && $FirstClockInDate <= $EndShift ){
                                //     // $FirstClockInPreDate = date( 'Y-m-d', strtotime($FirstClockInPre));
                                //     $dtScheduleShift = $ScheduleTbl->getALLShiftScheduleShiftPattern($ShopIDList[$i], $StartShift, $FirstClockInPre, $AppNotStampedShiftType);
                                //     $ShiftHour = "00:00:00";
                                //     foreach ($dtScheduleShift as $key => $value) {
                                //         if ($value["type"] === 'temp_shift') {
                                //             $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //             $Break  = $value->update_break;
                                //             $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //         } else {
                                //             $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //             $Break  = $value->break;
                                //             $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //         }
                                //         if ( $EndShiftTime > ($FirstClockInDate . " 00:00:00")) {
                                //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockInDate . " 00:00:00", $Break);
                                //         } else {
                                //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                //         }
                                //         $ShiftHour = $this->summationTime($ShiftHour, $hour);
                                //     }
                                //     //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)
                                //     $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $ShiftHour);

                                //     //Pattern1-7の対象期間開始日の前日からのシフト時間を集計する。
                                //     $dtSchedulePre = $ScheduleTbl->getALLShiftScheduleShiftTarget($ShopIDList[$i], $StartShift, $AppNotStampedShiftType);
                                //     $totalHour = "00:00:00";
                                //     foreach ($dtSchedulePre as $key => $value) {
                                //         if ($value->type === 'temp_shift') {
                                //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //             $DayBeforeBreak = $value->update_break;
                                //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //         } else {
                                //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //             $DayBeforeBreak = $value->break;
                                //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //         }

                                //         $start1 = $DayBeforeStartShiftTime;
                                //         $end1   = $StartShift . " 00:00:00";
                                //         $start2 = $end1;
                                //         $end2   = $DayBeforeEndShiftTime;
                                //         $break  = $DayBeforeBreak;
                                //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //         //集計項目
                                //         $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                //     }
                                //     //PatternPast[]	←	PatternPast[] + 計算した労働時間
                                //     $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);
                                // }
                                //・Pattern1-7の最初の打刻日の前日から打刻日時以前の確定シフト時間を集計する。 ( PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日 の場合)
                                // if( $StartShift <= $FirstClockInDate && $FirstClockInDate <= $EndShift ){
                                //     //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                                //     $totalHour = "00:00:00";
                                //     //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                                //     $dtSchedule = $ScheduleTbl->getALLScheduleShiftFirstClockIn($ShopIDList[$i], $FirstClockInPre, $FirstClockInDate, $AppNotStampedShiftType);
                                //     foreach ($dtSchedule as $key => $value) {
                                //         if ($value->type === 'temp_shift') {
                                //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //             $DayBeforeBreak = $value->update_break;
                                //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //         } else {
                                //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //             $DayBeforeBreak = $value->break;
                                //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //         }

                                //         $start1 = $DayBeforeStartShiftTime;
                                //         $end1   = $FirstClockInDate . " 00:00:00";
                                //         $start2 = $end1;
                                //         $end2   = $DayBeforeEndShiftTime;
                                //         $break  = $DayBeforeBreak;
                                //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //         //最初の打刻が、シフト時間内の場合、シフト時間から、その差分を引く。
                                //         //< DayBeforeEndShiftTime <= ShopIDList[].FirstClockIn の場合 >
                                //         if ( $DayBeforeEndShiftTime <= $FirstClockIn) {
                                //             //PatternPast[]		←	PatternPast[] + 当日労働時間の計算結果
                                //             $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                //         } else {
                                //             //< DayBeforeEndShiftTime > ShopIDList[].FirstClockIn の場合 >
                                //             //PatternPast[] + 当日労働時間の計算結果 -  ( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
                                //             //PatternPast[] + 当日労働時間の計算結果
                                //             $hourstart = $this->summationTime($totalHour, $data["WorkHour"]);
                                //             //( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
                                //             $ShiftTime = Chronos::parse($DayBeforeEndShiftTime);
                                //             $FirstClockInShift = Chronos::parse($FirstClockIn);
                                //             $diff = $FirstClockInShift->diff($ShiftTime);
                                //             $hourend = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                //             if ($hourstart > $hourend) $totalHour = $this->subtractionTime($hourstart, $hourend);
                                //         }
                                //     }
                                //     $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);

                                //     //・FirstClockInの日で最初の打刻以前の確定シフト時間を計算する。
                                //     $dtSchedule = $ScheduleTbl->getScheduleALLShiftTimeFirstClockIn($ShopIDList[$i], $FirstClockInDate . " 00:00:00", $FirstClockIn, $AppNotStampedShiftType);
                                //     $ShiftHour = "00:00:00";
                                //     $SumShiftHour = "00:00:00";
                                //     foreach ($dtSchedule as $key => $value) {
                                //         if ($value->type === 'temp_shift') {
                                //             $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //             $ShiftBreak = $value->update_break;
                                //             $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //         } else {
                                //             $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //             $ShiftBreak = $value->break;
                                //             $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //         }
                                //         if ($EndShiftTime <= $FirstClockIn) {
                                //             $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                //         } else {
                                //             // ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合
                                //             $StartShiftTime = Chronos::parse($StartShiftTime);
                                //             $FirstClockInShift = Chronos::parse($FirstClockIn);
                                //             $diff = $FirstClockInShift->diff($StartShiftTime);
                                //             $time1 = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                //             $time2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                //             //<  ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合>
                                //             if ( $time1 >= $time2 ) {
                                //                 //最初の打刻以前の労働時間が予定シフト時間以上の場合、休憩時間は取得済みとして計算する。
                                //                 $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockIn, $ShiftBreak);
                                //             } else {
                                //                 $ShiftHour = $time1;
                                //             }
                                //         }
                                //         $SumShiftHour = $this->summationTime($SumShiftHour, $ShiftHour);
                                //     }
                                //     //PatternPast[]	←	PatternPast[] + 計算した労働時間
                                //     $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $SumShiftHour);
                                // }
                            }
                            // Delete v.0.12.0
                            //28 hours limit(過去初回打刻日より前)
                            //・PatternPast[] の終了日 < FirstClockInのDate の場合の集計処理を行う。
                            // if ( $EndShift < $FirstClockInDate) {
                            //     $dtScheduleShift = $ScheduleTbl->getALLShiftScheduleShiftPattern($ShopIDList[$i], $StartShift, $EndShift, $AppNotStampedShiftType);
                            //     $ShiftHour = "00:00:00";
                            //     foreach ($dtScheduleShift as $key => $value) {
                            //         if ($value["type"] === 'temp_shift') {
                            //             $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                            //             $Break  = $value->update_break;
                            //             $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                            //         } else {
                            //             $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //             $Break  = $value->break;
                            //             $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                            //         }

                            //         $EndNextDate = date( 'Y-m-d', strtotime('+1 day' , strtotime ( $EndShift )));

                            //         if ( $EndShiftTime > ($EndNextDate . " 00:00:00")) {
                            //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndNextDate . " 00:00:00", $Break);
                            //         } else {
                            //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                            //         }
                            //         $ShiftHour = $this->summationTime($ShiftHour, $hour);
                            //     }
                            //     //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)
                            //     $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $ShiftHour);

                            //     //Pattern1-7の対象期間開始日の前日からのシフト時間を集計する。
                            //     $dtSchedulePre = $ScheduleTbl->getALLShiftScheduleShiftTarget($ShopIDList[$i], $StartShift, $AppNotStampedShiftType);
                            //     $totalHour = "00:00:00";
                            //     foreach ($dtSchedulePre as $key => $value) {
                            //         if ($value->type === 'temp_shift') {
                            //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                            //             $DayBeforeBreak = $value->update_break;
                            //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                            //         } else {
                            //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //             $DayBeforeBreak = $value->break;
                            //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                            //         }
                            //         $start1 = $DayBeforeStartShiftTime;
                            //         $end1   = $StartShift . " 00:00:00";
                            //         $start2 = $end1;
                            //         $end2   = $DayBeforeEndShiftTime;
                            //         $break  = $DayBeforeBreak;
                            //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //         //集計項目
                            //         $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                            //     }
                            //     //PatternPast[]	←	PatternPast[] + 計算した労働時間
                            //     $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);
                            // }
                        }
                    }
                    //・未来の労働時間を計算する。
                    //・チェック対象期間が現在日よりあとの場合 ( 28CheckStartDate > CurrentDate の場合)
                    if($_28CheckStartDate > $CurrentDate){
                        for ($j=0; $j < 7; $j++) {
                            if (!$PatternSchedule[$j]['flg_schedule']) continue;
                            $StartShift	= date( 'Y-m-d', strtotime($PatternSchedule[$j]["start"]));
                            $EndShift	= date( 'Y-m-d', strtotime($PatternSchedule[$j]["end"]));

                            $dtSch = $ScheduleTbl->getShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $Break = $value["update_break"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $Break = $value["break"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }

                                $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                                //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                                if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                                } else {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                }
                                $total = $this->summationTime($total, $ShiftHour);
                            }
                            //PatternSchedule[]		←		SUM(ShiftHour)
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                            $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                            //・対象期間開始日の前日からの確定シフト時間
                            $dtSch = $ScheduleTbl->getShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $DayBeforeBreak = $value["update_break"];
                                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $DayBeforeBreak = $value["break"];
                                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }

                                $start1 = $DayBeforeStartShiftTime;
                                $end1   = $StartShift . " 00:00:00";
                                $start2 = $end1;
                                $end2   = $DayBeforeEndShiftTime;
                                $break  = $DayBeforeBreak;
                                //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //集計項目
                                $total = $this->summationTime($total, $data["WorkHour"]);
                            }
                            //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                        }
                    }

                    //・過去+未来の労働時間を計算する。
                    if($_28CheckStartDate <= $CurrentDate && $CurrentDate <= $_28CheckEndDate){
                        //チェック対象期間内に存在するCurrentDateの1日前までを過去の労働時間として集計する。
                        //・Pattern1-7の対象期間開始日から、CurrentDate -1日までの労働時間を集計する。 ( PatternPast[] の開始日 <  CurrentDate の場合)
                        for ($j=0; $j < 7; $j++) {
                            $StartShift	= date( 'Y-m-d', strtotime($PatternPast[$j]["start"]));
                            $EndShift	= date( 'Y-m-d', strtotime($PatternPast[$j]["end"]));
                            //「・過去の労働時間を計算する。」
                            // if(!is_null($FirstClockIn)){
                            if($PatternPast[$j]['start'] < $CurrentDate.' 00:00:00'){
                                // if($PatternPast[$j]['end'] < $CurrentDate.' 00:00:00'){
                                //     $Today = $PatternPast[$j]['end'];
                                // }else{
                                //     $Today = date( 'Y-m-d 00:00:00' , strtotime('-1 day' , strtotime ( $CurrentDate )));
                                // }
                                //・連携店舗の労働時間
                                //長期休暇が存在するため、28CheckStartDateまたは28CheckEndDate が Pattern1-6 の期間と一致しない場合があるため、長期休暇日を集計しないように注意すること。
                                $TotalWorkHour28h = "00:00:00";
                                $PatternPastEnd = date( 'Y-m-d 00:00:00', strtotime('+1 day' , strtotime ( $PatternPast[$j]['end'] )));
                                $arrTimePattern = [
                                    "start" => $PatternPast[$j]["start"],
                                    "end" => $PatternPast[$j]["end"]
                                ];
                                $dtAtten = $AttendanceTbl->getShiftAttendance28h($ShopIDList[$i], $arrTimePattern);
                                foreach ($dtAtten as $key => $value) {
                                    $StartWorkTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    // $Break =  $value["break_times"];
                                    // $EndWorkTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                    $Break = $value["break_times"];
                                    $date = $this->checkNullFormatDate($value["date"], 'Y-m-d');
                                    if ( $date === $preCurrentDate ) {
                                        $Break = (is_null($Break)) ? $LatestBreak : $Break;
                                    }
                                    $Break = (is_null($Break)) ? 0 : $Break;
                                    // $EndWorkTime =  $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                    $endTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                    $EndWorkTime = (is_null($endTime)) ? $CurrentDateTime : $endTime ;

                                    //IF(EndWorkTime > ToDay + 1day + ' 00:00:00', ToDay + 1day + ' 00:00:00',  EndWorkTime) - StartWorkTime - Break
                                    if ($EndWorkTime > $PatternPastEnd) {
                                        $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $PatternPastEnd, $Break);
                                    } else {
                                        $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $EndWorkTime, $Break);
                                    }
                                    //集計項目
                                    $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $WorkHour);
                                }
                                //PatternPast[]	← SUM(WorkHour)
                                $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $TotalWorkHour28h);

                                //・Pattern1-7の対象期間開始日の前日からの労働時間
                                $arrTimePattern = [
                                    "start" => $StartShift,
                                    "end" => $EndShift
                                ];
                                $dtAttenPre = $AttendanceTbl->getShiftAttendancePreDay($ShopIDList[$i], $arrTimePattern);
                                $TotalWorkHour28h = "00:00:00";
                                foreach ($dtAttenPre as $key => $value) {
                                    //・Record件数 > 0 の場合は、労働時間を計算する。
                                    $DayBeforeStartWorkTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                    $DayBeforeStartBreak = $value->break;
                                    $DayBeforeEndWorkTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');

                                    $start1 = $DayBeforeStartWorkTime;
                                    $end1   = $PatternPast[$j]["start"];
                                    $start2 = $end1;
                                    $end2   = $DayBeforeEndWorkTime;
                                    $break  = $DayBeforeStartBreak;
                                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                    //集計項目
                                    $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $data["WorkHour"]);
                                }
                                //PatternPast[]	 ←	PatternPast[] + 計算した労働時間
                                $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $TotalWorkHour28h);
                                if(!is_null($FirstClockIn)){
                                    //Delete v.0.12.0
                                    //・PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日の場合の集計処理を行う。
                                    // if( $StartShift <= $FirstClockInDate && $FirstClockInDate <= $EndShift) {
                                    //     //Pattern1-7（-6日から+6日までのPattern）分を取得する。
                                    //     //PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日
                                    //     //・対象期間に最初の打刻日が含まれる場合は最初の打刻日の1日前まで集計する。（ PatternPast[] の開始日 < FirstClockInのDate <= PatternPast[] の終了日 の場合）
                                    //     $FirstClockInPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $FirstClockInDate )));
                                    //     // $TodayDate= date( 'Y-m-d', strtotime ( $PatternPast[$j]['end'] ));
                                    //     if( $StartShift < $FirstClockInDate && $FirstClockInDate <= $EndShift){
                                    //         // $EndShift = date( 'Y-m-d', strtotime($FirstClockInPre));
                                    //         $dtScheduleShift = $ScheduleTbl->getALLShiftScheduleShiftPattern($ShopIDList[$i], $StartShift, $FirstClockInPre, $AppNotStampedShiftType);
                                    //         $ShiftHour = "00:00:00";
                                    //         foreach ($dtScheduleShift as $key => $value) {
                                    //             if ($value["type"] === 'temp_shift') {
                                    //                 $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                    //                 $Break  = $value->update_break;
                                    //                 $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                    //             } else {
                                    //                 $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                    //                 $Break  = $value->break;
                                    //                 $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                    //             }

                                    //             if ( $EndShiftTime > ($FirstClockInDate . " 00:00:00")) {
                                    //                 $hour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockInDate . " 00:00:00", $Break);
                                    //             } else {
                                    //                 $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                    //             }
                                    //             $ShiftHour = $this->summationTime($ShiftHour, $hour);
                                    //         }
                                    //         //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)
                                    //         $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $ShiftHour);

                                    //         //Pattern1-7の対象期間開始日の前日からのシフト時間を集計する。
                                    //         $dtSchedulePre = $ScheduleTbl->getALLShiftScheduleShiftTarget($ShopIDList[$i], $StartShift, $AppNotStampedShiftType);
                                    //         $totalHour = "00:00:00";
                                    //         foreach ($dtSchedulePre as $key => $value) {
                                    //             if ($value->type === 'temp_shift') {
                                    //                 $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                    //                 $DayBeforeBreak = $value->update_break;
                                    //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                    //             } else {
                                    //                 $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                    //                 $DayBeforeBreak = $value->break;
                                    //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                    //             }
                                    //             $start1 = $DayBeforeStartShiftTime;
                                    //             $end1   = $StartShift . " 00:00:00";
                                    //             $start2 = $end1;
                                    //             $end2   = $DayBeforeEndShiftTime;
                                    //             $break  = $DayBeforeBreak;
                                    //             //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                    //             $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                    //             //集計項目
                                    //             $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                    //         }
                                    //         //PatternPast[]	←	PatternPast[] + 計算した労働時間
                                    //         $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);
                                    //     }

                                    //     //・Pattern1-7の最初の打刻日の前日から打刻日時以前の確定シフト時間を集計する。 ( PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日 の場合)
                                    //     if( $StartShift <= $FirstClockInDate && $FirstClockInDate <= $EndShift){
                                    //         //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                                    //         $totalHour = "00:00:00";
                                    //         //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                                    //         $dtSchedule = $ScheduleTbl->getALLScheduleShiftFirstClockIn($ShopIDList[$i], $FirstClockInPre, $FirstClockInDate, $AppNotStampedShiftType);
                                    //         foreach ($dtSchedule as $key => $value) {
                                    //             if ($value->type === 'temp_shift') {
                                    //                 $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                    //                 $DayBeforeBreak = $value->update_break;
                                    //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                    //             } else {
                                    //                 $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                    //                 $DayBeforeBreak = $value->break;
                                    //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                    //             }
                                    //             $start1 = $DayBeforeStartShiftTime;
                                    //             $end1   = $FirstClockInDate . " 00:00:00";
                                    //             $start2 = $end1;
                                    //             $end2   = $DayBeforeEndShiftTime;
                                    //             $break  = $DayBeforeBreak;
                                    //             //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                    //             $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                    //             //最初の打刻が、シフト時間内の場合、シフト時間から、その差分を引く。
                                    //             //< DayBeforeEndShiftTime <= ShopIDList[].FirstClockIn の場合 >
                                    //             if ( $DayBeforeEndShiftTime <= $FirstClockIn) {
                                    //                 //PatternPast[]		←	PatternPast[] + 当日労働時間の計算結果
                                    //                 $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                    //             } else {
                                    //                 //< DayBeforeEndShiftTime > ShopIDList[].FirstClockIn の場合 >
                                    //                 //PatternPast[] + 当日労働時間の計算結果 -  ( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
                                    //                 //PatternPast[] + 当日労働時間の計算結果
                                    //                 $hourstart = $this->summationTime($totalHour, $data["WorkHour"]);
                                    //                 //( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
                                    //                 $ShiftTime = Chronos::parse($DayBeforeEndShiftTime);
                                    //                 $FirstClock = Chronos::parse($FirstClockIn);
                                    //                 $diff = $FirstClock->diff($ShiftTime);
                                    //                 $hourend = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                    //                 if ($hourstart > $hourend) $totalHour = $this->subtractionTime($hourstart, $hourend);
                                    //             }
                                    //         }
                                    //         $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);

                                    //         //・FirstClockInの日で最初の打刻以前の確定シフト時間を計算する。
                                    //         $dtSchedule = $ScheduleTbl->getScheduleALLShiftTimeFirstClockIn($ShopIDList[$i], $FirstClockInDate . " 00:00:00", $FirstClockIn, $AppNotStampedShiftType);
                                    //         $ShiftHour = "00:00:00";
                                    //         $SumShiftHour = "00:00:00";
                                    //         foreach ($dtSchedule as $key => $value) {
                                    //             if ($value->type === 'temp_shift') {
                                    //                 $StartShiftTime =  $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                    //                 $ShiftBreak = $value->update_break;
                                    //                 $EndShiftTime =  $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                    //             } else {
                                    //                 $StartShiftTime =  $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                    //                 $ShiftBreak = $value->break;
                                    //                 $EndShiftTime =  $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                    //             }
                                    //             if ($EndShiftTime <= $FirstClockIn) {
                                    //                 $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                    //             } else {
                                    //                 // ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合
                                    //                 $StartShiftTime = Chronos::parse($StartShiftTime);
                                    //                 $FirstClock = Chronos::parse($FirstClockIn);
                                    //                 $diff = $FirstClock->diff($StartShiftTime);
                                    //                 $time1 = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                    //                 $time2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                    //                 //<  ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合>
                                    //                 if ( $time1 >= $time2 ) {
                                    //                     //最初の打刻以前の労働時間が予定シフト時間以上の場合、休憩時間は取得済みとして計算する。
                                    //                     $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockIn, $ShiftBreak);
                                    //                 } else {
                                    //                     $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockIn, 0);
                                    //                 }
                                    //             }
                                    //             $SumShiftHour = $this->summationTime($SumShiftHour, $ShiftHour);
                                    //         }
                                    //         //PatternPast[]	←	PatternPast[] + 計算した労働時間
                                    //         $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $SumShiftHour);
                                    //     }
                                    // }
                                    //28 hours limit(過去初回打刻日より前)
                                    //・PatternPast[] の終了日 < FirstClockInのDate の場合の集計処理を行う。
                                    // if ( $EndShift < $FirstClockInDate) {
                                    //     $dtScheduleShift = $ScheduleTbl->getALLShiftScheduleShiftPattern($ShopIDList[$i], $StartShift, $EndShift, $AppNotStampedShiftType);
                                    //     $ShiftHour = "00:00:00";
                                    //     foreach ($dtScheduleShift as $key => $value) {
                                    //         if ($value["type"] === 'temp_shift') {
                                    //             $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                    //             $Break  = $value->update_break;
                                    //             $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                    //         } else {
                                    //             $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                    //             $Break  = $value->break;
                                    //             $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                    //         }
                                    //         $EndNextDate = date( 'Y-m-d', strtotime('+1 day' , strtotime ( $EndShift )));

                                    //         if ( $EndShiftTime > ($EndNextDate . " 00:00:00")) {
                                    //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndNextDate . " 00:00:00", $Break);
                                    //         } else {
                                    //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                    //         }
                                    //         $ShiftHour = $this->summationTime($ShiftHour, $hour);
                                    //     }
                                    //     //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)
                                    //     $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $ShiftHour);

                                    //     //Pattern1-7の対象期間開始日の前日からのシフト時間を集計する。
                                    //     $dtSchedulePre = $ScheduleTbl->getALLShiftScheduleShiftTarget($ShopIDList[$i], $StartShift, $AppNotStampedShiftType);
                                    //     $totalHour = "00:00:00";
                                    //     foreach ($dtSchedulePre as $key => $value) {
                                    //         if ($value->type === 'temp_shift') {
                                    //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                    //             $DayBeforeBreak = $value->update_break;
                                    //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                    //         } else {
                                    //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                    //             $DayBeforeBreak = $value->break;
                                    //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                    //         }
                                    //         $start1 = $DayBeforeStartShiftTime;
                                    //         $end1   = $StartShift . " 00:00:00";
                                    //         $start2 = $end1;
                                    //         $end2   = $DayBeforeEndShiftTime;
                                    //         $break  = $DayBeforeBreak;
                                    //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                    //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                    //         //集計項目
                                    //         $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                    //     }
                                    //     //PatternPast[]	←	PatternPast[] + 計算した労働時間
                                    //     $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);
                                    // }
                                }
                            }
                            // }
                            //「・未来の労働時間を計算する」
                            if($PatternSchedule[$j]['start'] > $CurrentDate.' 00:00:00' && $PatternSchedule[$j]['flg_schedule']){
                                //・チェック対象期間が現在日よりあとの場合 ( 28CheckStartDate > CurrentDate の場合)
                                // if($CurrentDate > $_28CheckEndDate){
                                // if($_28CheckStartDate > $CurrentDate ){
                                    // $CurrentDateNext = date( 'Y-m-d', strtotime('+1 days', strtotime($CurrentDate)));
                                    $StartShift	= date( 'Y-m-d', strtotime($PatternSchedule[$j]["start"]));
                                    $EndShift	= date( 'Y-m-d', strtotime($PatternSchedule[$j]["end"]));

                                    $dtSch = $ScheduleTbl->getShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $SearchShiftType, $TotalType);
                                    $total = "00:00:00";
                                    foreach ($dtSch as $key => $value) {
                                        if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                            $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                            $Break = $value["update_break"];
                                            $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                        } else {
                                            $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                            $Break = $value["break"];
                                            $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                        }

                                        $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                                        //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                                        if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                                            $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                                        } else {
                                            $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                        }
                                        $total = $this->summationTime($total, $ShiftHour);
                                    }
                                    //PatternSchedule[]		←		SUM(ShiftHour)
                                    $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                                    $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                                    //・対象期間開始日の前日からの確定シフト時間
                                    $dtSch = $ScheduleTbl->getShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                                    $total = "00:00:00";
                                    foreach ($dtSch as $key => $value) {
                                        if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                            $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                            $DayBeforeBreak = $value["update_break"];
                                            $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                        } else {
                                            $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                            $DayBeforeBreak = $value["break"];
                                            $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                        }
                                        $start1 = $DayBeforeStartShiftTime;
                                        $end1   = $StartShift . " 00:00:00";
                                        $start2 = $end1;
                                        $end2   = $DayBeforeEndShiftTime;
                                        $break  = $DayBeforeBreak;
                                        //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                        $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                        //集計項目
                                        $total = $this->summationTime($total, $data["WorkHour"]);
                                    }
                                    //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間
                                    $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                                // }
                            }
                        }
                    }
                }
            }

            // チェック対象期間内にCurrentDateが含まれる場合、CurrentDateの労働時間を計算する。（28CheckStartDate <= CurrentDate <= 28CheckEndtDate の場合
            if($_28CheckStartDate <= $CurrentDate && $CurrentDate <= $_28CheckEndDate){
                //---------------log start---------------------
                $this->writeLog28h('UserController', 'CalculateShiftWorkTime28Hour', '28 hour limit - チェック対象期間内にCurrentDateが含まれる場合、CurrentDateの労働時間を計算する。（28CheckStartDate <= CurrentDate <= 28CheckEndtDate の場合', '', $CurrentDate, '');
                //---------------log end------------------------
                $TodayWorkHour = "00:00:00";
                //・最新の打刻情報が取得できた場合 ( LatestWorkID != null )
                if (!is_null($LatestWorkID)) {
                    //・ LatestWorkStartTimeのDate < CurrentDate AND LatestWorkEndTime = null の場合、下記の処理を行う。
                    if($LatestWorkStart < $CurrentDate && is_null($LatestWorkEndTime)) {
                        //・休憩中の場合（ LatestStartBreakTime != null）
                        if(!is_null($LatestStartBreakTime)) {
                            $start1 = $LatestWorkStartTime;
                            $end1   = $CurrentDate . " 00:00:00";
                            $start2 = $end1;
                            $end2   = ($LatestStartBreakTime <=  $end1) ? $end1 : $LatestStartBreakTime;
                            $break  = $LatestBreak;
                        } else {
                            //・休憩中以外の場合（ LatestStartBreakTime = null）
                            $start1 = $LatestWorkStartTime;
                            $end1   = $CurrentDate . " 00:00:00";
                            $start2 = $end1;
                            $end2   = $CurrentDateTime;
                            $break  = $LatestBreak;
                            $rs["ClockIn"] = "yes";
                        }
                        //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                        $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                        $rs["TodayWorkHour"] = $data["WorkHour"];
                        $rs["PreviousDayUsedBreakTime"] = $break;
                    }
                    //・ LatestWorkStartTimeのDate < CurrentDate AND LatestWorkEndTimeのDate = CurrentDate の場合、下記の処理を行う。
                    if ($LatestWorkStart < $CurrentDate && $LatestWorkEnd == $CurrentDate) {
                        $start1 = $LatestWorkStartTime;
                        $end1   = $CurrentDate . " 00:00:00";
                        $start2 = $end1;
                        $end2   = $LatestWorkEndTime;
                        $break  = $LatestBreak;
                        //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                        $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                        $TodayWorkHour = $this->summationTime($TodayWorkHour, $data["WorkHour"]);
                        $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TodayWorkHour);
                    }
                }
                //・最新の打刻が取得できない OR 最新打刻が当日の場合、下記の処理を行う。( LatestWorkID = null OR LatestWorkStartTimeのDate = CurrentDate )
                // if (is_null($LatestWorkID) || $LatestWorkStart == $CurrentDate) {
                    //ShopIDList のshop_id単位で以下の処理をLoopする。
                    for ($j=0; $j < sizeof($ShopIDList); $j++) {
                        $TodayWorkHour = "00:00:00";
                        // Delete v.0.12.0
                        // if($ShopIDList[$j]['FirstClockIn'] !== null && date( 'Y-m-d' , strtotime( $ShopIDList[$j]['FirstClockIn']))  === $CurrentDate ){
                        //     //最初の打刻が当日の場合、前日から当日の確定シフト時間を取得する。
                        //     $DayBeforeStartShiftTime = null;
                        //     $DayBeforeBreak = null;
                        //     $DayBeforeEndShiftTime = null;
                        //     $dtSchePre = $ScheduleTbl->getALLShiftSchePreDay($ShopIDList[$j], $CurrentDate, $AppNotStampedShiftType);
                        //     if (sizeof($dtSchePre) > 0) {
                        //         for ($i=0; $i < sizeof($dtSchePre); $i++) {
                        //             //・Record件数 > 0 の場合は、労働時間を計算する。
                        //             if ($dtSchePre[$i]['type'] === 'temp_shift') {
                        //                 $DayBeforeStartShiftTime = $dtSchePre[$i]["update_start"];
                        //                 $DayBeforeBreak = $dtSchePre[$i]["update_break_times"];
                        //                 $DayBeforeEndShiftTime = $dtSchePre[$i]["update_end"];
                        //             } else {
                        //                 $DayBeforeStartShiftTime = $dtSchePre[$i]["start"];
                        //                 $DayBeforeBreak = $dtSchePre[$i]["break_times"];
                        //                 $DayBeforeEndShiftTime = $dtSchePre[$i]["end"];
                        //             }
                        //             $start1 = $DayBeforeStartShiftTime;
                        //             $end1   = $CurrentDate . " 00:00:00";
                        //             $start2 = $end1;
                        //             $end2   = $DayBeforeEndShiftTime <= $ShopIDList[$j]['FirstClockIn'] ? $DayBeforeEndShiftTime : $ShopIDList[$j]['FirstClockIn'];
                        //             $break  = $DayBeforeBreak;
                        //             // }
                        //             //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                        //             $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                        //             $TodayWorkHour = $this->summationTime($TodayWorkHour, $data["WorkHour"]);
                        //         }
                        //         $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TodayWorkHour);
                        //     }
                        // }
                        //最初の打刻が当日より前の場合（ ShopIDList[].FirstClockInのDate < CurrentDate AND ShopIDList[].FirstClockIn != null）
                        // if($ShopIDList[$j]['FirstClockIn'] !== null && date( 'Y-m-d' , strtotime( $ShopIDList[$j]['FirstClockIn'])) < $CurrentDate ){
                            $DayBeforeStartWorkTime = null;
                            $DayBeforeStartBreak = null;
                            $DayBeforeEndWorkTime = null;
                            $dtAttPre = $AttendanceTbl->getAttendanceShiftPreDay($ShopIDList[$j], $CurrentDate, $LatestWorkID);
                            if (sizeof($dtAttPre) > 0) {
                                for ($i=0; $i < sizeof($dtAttPre); $i++) {
                                    //・Record件数 > 0 の場合は、労働時間を計算する。
                                    $DayBeforeStartWorkTime = $this->checkNullFormatDate($dtAttPre[$i]->start, 'Y-m-d H:i:00');
                                    $DayBeforeStartBreak = $dtAttPre[$i]->break;
                                    $DayBeforeEndWorkTime = $this->checkNullFormatDate($dtAttPre[$i]->end, 'Y-m-d H:i:00');

                                    $start1 = $DayBeforeStartWorkTime;
                                    $end1   = $CurrentDate . " 00:00:00";
                                    $start2 = $end1;
                                    $end2   = $DayBeforeEndWorkTime;
                                    $break  = $DayBeforeStartBreak;
                                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                    $TodayWorkHour = $this->summationTime($TodayWorkHour, $data["WorkHour"]);

                                }
                                $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TodayWorkHour);
                            }
                        // }
                    }
                // }

                //・当日の労働時間を取得する。
                //・最新の打刻が取得できた( LatestWorkID != null ) AND LatestWorkStartTimeのDate = CurrentDate の場合、下記の処理を行う。
                $TotalWorkHour = "00:00:00";
                $SumHour = "00:00:00";
                if (!is_null($LatestWorkID) && ($LatestWorkStart == $CurrentDate)) {
                    //・最新の勤怠以前の労働時間を計算する。
                    $dtAttenLast = $AttendanceTbl->getAttenLast($UserEmployIDList, $mergeShopID, $CurrentDate, $LatestWorkID, $CurrentDateTime);
                    if (sizeof($dtAttenLast) > 0) {
                        for ($i=0; $i < sizeof($dtAttenLast); $i++) {
                            $StartWorkTime = $this->checkNullFormatDate($dtAttenLast[$i]["start"], 'Y-m-d H:i:00');
                            $Break =  $dtAttenLast[$i]["break"];
                            $EndWorkTime = $this->checkNullFormatDate($dtAttenLast[$i]["end"], 'Y-m-d H:i:00');

                            $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $EndWorkTime, $Break);
                            //集計項目
                            $SumHour = $this->summationTime($SumHour, $WorkHour);
                        }
                    }
                    //・最新の労働時間を足す。
                    $hour = "00:00:00";
                    if (!is_null($LatestWorkEndTime)) {
                        //TodayWorkHour + ( LatestWorkEndTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                        $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $LatestWorkEndTime, $LatestBreak);
                        $TotalWorkHour = $this->summationTime($hour, $SumHour);
                    } else {
                        if (is_null($LatestStartBreakTime)) {
                            //TodayWorkHour + ( CurrentDateTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                            $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $CurrentDateTime, $LatestBreak);
                            $TotalWorkHour = $this->summationTime($hour, $SumHour);
                            $rs["ClockIn"] = "yes";
                        } else  {
                            //TodayWorkHour + ( LatestStartBreakTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                            $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $LatestStartBreakTime, $LatestBreak);
                            $TotalWorkHour = $this->summationTime($hour, $SumHour);
                        }
                    }
                    $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TotalWorkHour);

                    if($LatestWorkEndTime === null && $LatestStartBreakTime === null){
                        $rs["TodayUsedBreakTime"]= $LatestBreak;
                    }else if($LatestWorkEndTime === null && $LatestStartBreakTime !== null){
                        // $rs["TodayUsedBreakTime"] = $this->calWorkTimeToBreak($LatestStartBreakTime, $CurrentDateTime, $LatestBreak);
                        $rs["TodayUsedBreakTime"] = $LatestBreak;
                    }
                }

                // //ShopIDList のshop_id単位で以下の処理をLoopする。
                // for ($j=0; $j < sizeof($ShopIDList); $j++) {
                //     //最初の打刻が無い場合（ ShopIDList[].FirstClockIn = null ）
                //     if($ShopIDList[$j]['FirstClockIn'] === null){
                //         $StartUserShiftTime = null;
                //         $Break = null;
                //         $EndUserShiftTime = null;
                //         $UserShiftHour = null;
                //         $dtScheCur = $ScheduleTbl->getShiftScheCurrentDay($ShopIDList[$j], $CurrentDate, $CurrentDateTime);
                //         if (sizeof($dtScheCur) > 0) {
                //             for ($i=0; $i < sizeof($dtScheCur); $i++) {
                //                 //・Record件数 > 0 の場合は、労働時間を計算する。
                //                 $StartUserShiftTime = $this->checkNullFormatDate($dtScheCur[$i]->start, 'Y-m-d H:i:00');
                //                 $Break = $dtScheCur[$i]->break_times;
                //                 $EndUserShiftTime = $this->checkNullFormatDate($dtScheCur[$i]->end, 'Y-m-d H:i:00');
                //                 $UserShiftHour = $this->calWorkTimeToBreak($StartUserShiftTime, $EndUserShiftTime, $Break);
                //                 //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                //                 $TodayWorkHour = $this->summationTime($TodayWorkHour, $UserShiftHour);
                //             }
                //         }
                //     }
                // }
                // $rs["TodayWorkHour"] = $TodayWorkHour;
                // Delete v.0.12.0
                // //v.0.8.0
                // //・当日の FirstClockIn 以前の予定時間を確定シフト時間から計算する。
                // for ($j=0; $j < sizeof($ShopIDList); $j++) {
                //     if ($ShopIDList[$j]['FirstClockIn'] !== null) {
                //         $FirstClockInDate = date( 'Y-m-d' , strtotime( $ShopIDList[$j]['FirstClockIn']));
                //         $this->writeLog28h('UserController', 'CalculateShiftWorkTime28Hour', '28 hour limit - 当日の FirstClockIn 以前の予定時間を確定シフト時間から計算する。', '', $FirstClockInDate . " 00:00:00",  $ShopIDList[$j]['FirstClockIn']);
                //         if ($FirstClockInDate === $CurrentDate) {
                //             $arrayShop = [];
                //             array_push($arrayShop, $ShopIDList[$j]["shop_id"]);
                //             $dtSchedule = $ScheduleTbl->getScheduleALLShiftTimePattern($ShopIDList[$j]["employee_id"], $arrayShop, $FirstClockInDate . " 00:00:00", $ShopIDList[$j]['FirstClockIn'], $AppNotStampedShiftType);
                //             $TodayWorkHour = "00:00:00";
                //             if (sizeof($dtSchedule) > 0) {
                //                 for ($i=0; $i < sizeof($dtSchedule); $i++) {
                //                     //・Record件数 > 0 の場合は、労働時間を計算する。
                //                     if ($dtSchedule[$i]->type === 'temp_shift' ) {
                //                         $StartShiftTime = $this->checkNullFormatDate($dtSchedule[$i]->update_start, 'Y-m-d H:i:00');
                //                         $ShiftBreak = $dtSchedule[$i]->update_break;
                //                         $EndShiftTime = $this->checkNullFormatDate($dtSchedule[$i]->update_end, 'Y-m-d H:i:00');
                //                     } else {
                //                         $StartShiftTime = $this->checkNullFormatDate($dtSchedule[$i]->start, 'Y-m-d H:i:00');
                //                         $ShiftBreak = $dtSchedule[$i]->break;
                //                         $EndShiftTime = $this->checkNullFormatDate($dtSchedule[$i]->end, 'Y-m-d H:i:00');
                //                     }

                //                     if ($EndShiftTime <= $ShopIDList[$j]['FirstClockIn']){
                //                         $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                //                     } else {
                //                         $time1 = $this->calWorkTimeToBreak($StartShiftTime, $ShopIDList[$j]['FirstClockIn'], 0);
                //                         $time2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                //                         if($time1 >= $time2) {
                //                             $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $ShopIDList[$j]['FirstClockIn'], $ShiftBreak);
                //                         } else {
                //                             $ShiftHour = $time1;
                //                         }
                //                     }
                //                     //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                //                     $TodayWorkHour = $this->summationTime($TodayWorkHour, $ShiftHour);
                //                 }
                //                 $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TodayWorkHour);
                //             }
                //         }
                //     }
                // }

                //==========・当日の CurrentDateTime 以降の予定時間を確定シフト時間から計算する。==========
                //・連携店舗の確定シフト情報を取得する。
                //・前日から労働中の場合、前日からの確定シフト時間から残りの確定シフト時間を取得する。
                //・ LatestWorkStartTimeのDate < CurrentDate AND LatestWorkEndTime = null の場合、下記の処理を行う。
                $DayBeforeShiftHour = "00:00:00";
                // Delete v.0.12.5
                // if($LatestWorkStartTime !== null && date( 'Y-m-d' , strtotime($LatestWorkStartTime)) < $CurrentDate && $LatestWorkEndTime === null){
                //     $dtScheBefor = $ScheduleTbl->getALLShiftScheDayBefore($UserEmployIDList, $LatestWorkShopID, $CurrentDate, $CurrentDateTime, $SearchShiftType, $TotalType);
                //     if (sizeof($dtScheBefor) > 0) {
                //         for ($i=0; $i < sizeof($dtScheBefor); $i++) {
                //             //・Record件数 > 0 の場合は、労働時間を計算する。
                //             if ($TotalType === 'app' && $dtScheBefor[$i]->type === 'temp_shift') {
                //                 $DayBeforeShiftBreak = $dtScheBefor[$i]->update_break_times;
                //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->update_end, 'Y-m-d H:i:00');
                //             } else {
                //                 $DayBeforeShiftBreak = $dtScheBefor[$i]->break_times;
                //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->end, 'Y-m-d H:i:00');
                //             }
                //             $PreviousDayUsedBreakTime = $rs["PreviousDayUsedBreakTime"];
                //             // $SubBreak = $this->subtractionTime($DayBeforeShiftBreak, $PreviousDayUsedBreakTime);
                //             $SubBreak = (int) $DayBeforeShiftBreak - (int) $PreviousDayUsedBreakTime;
                //             if ( $SubBreak < 0) $SubBreak = 0;
                //             //・Record件数 > 0 の場合は、残りの確定シフト時間を計算する。
                //             $hour = $this->calWorkTimeToBreak($CurrentDateTime, $DayBeforeEndShiftTime, $SubBreak);
                //             $DayBeforeShiftHour = $this->summationTime($DayBeforeShiftHour, $hour);
                //         }
                //     }
                // }
                for ($j=0; $j < sizeof($ShopIDList); $j++) {
                    if ($ShopIDList[$j]['FirstClockIn'] !== null) {
                        $arrEmployee = [];
                        array_push($arrEmployee, $ShopIDList[$j]['employee_id']);
                        $dtScheBefor = $ScheduleTbl->getALLShiftScheDayBefore($arrEmployee, $ShopIDList[$j]["shop_id"], $CurrentDate, $CurrentDateTime, $SearchShiftType, $TotalType);
                        if (sizeof($dtScheBefor) > 0) {
                            for ($i=0; $i < sizeof($dtScheBefor); $i++) {
                                //・Record件数 > 0 の場合は、労働時間を計算する。
                                if ($TotalType == 'app' && $dtScheBefor[$i]->type === 'temp_shift') {
                                    $ShiftBreak = $dtScheBefor[$i]->update_break_times;
                                    $StartShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->update_start, 'Y-m-d H:i:00');
                                    $EndShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->update_end, 'Y-m-d H:i:00');
                                } else {
                                    $ShiftBreak = $dtScheBefor[$i]->break_times;
                                    $StartShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->start, 'Y-m-d H:i:00');
                                    $EndShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->end, 'Y-m-d H:i:00');
                                }

                                $start1 = $StartShiftTime;
                                $end1   = $CurrentDate . " 00:00:00";
                                $start2 = $end1;
                                $end2   = $EndShiftTime;
                                $break  = $ShiftBreak;
                                //当日の労働時間
                                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //現在時間の残りシフト時間	←	EndShiftTime - CurrentDateTime
                                $timeRemaining = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                                if ($data["WorkHour"] < $timeRemaining) {
                                    $DayBeforeShiftHour = $this->summationTime($DayBeforeShiftHour, $data["WorkHour"]);
                                } else {
                                    $DayBeforeShiftHour = $this->summationTime($DayBeforeShiftHour, $timeRemaining);
                                }
                            }
                        }
                    }
                }
                $TodayShiftHour = "00:00:00";
                $ShiftIDCurrentTime = null;
                // Delete v.0.12.5
                //・当日の確定シフトからCurrentDateTime 以降の確定シフト時間を取得する。
                //・当日から労働中の場合、残りのシフト時間の取得処理を行う。( LatestWorkStartTimeのDate = CurrentDate AND LatestWorkEndTime = null )
                // if($LatestWorkStartTime !== null && date( 'Y-m-d' , strtotime($LatestWorkStartTime)) === $CurrentDate && $LatestWorkEndTime === null){
                //     $dtScheAfterCur = $ScheduleTbl->getALLShiftScheDayAfterCur($UserEmployIDList, $LatestWorkShopID, $CurrentDateTime, $SearchShiftType, $TotalType);
                //     if (sizeof($dtScheAfterCur) > 0) {
                //         for ($i=0; $i < sizeof($dtScheAfterCur); $i++) {
                //             //・Record件数 > 0 の場合は、労働時間を計算する。
                //             $ShiftIDCurrentTime = $dtScheAfterCur[$i]->id;
                //             if ($TotalType === 'app' && $dtScheAfterCur[$i]->type === 'temp_shift') {
                //                 $StartShiftCurrentTime = $this->checkNullFormatDate($dtScheAfterCur[$i]->update_start, 'Y-m-d H:i:00');
                //                 $ShiftCurrentBreak = $dtScheAfterCur[$i]->update_break_times;
                //                 $EndShiftCurrentTime = $this->checkNullFormatDate($dtScheAfterCur[$i]->update_end, 'Y-m-d H:i:00');
                //             } else {
                //                 $StartShiftCurrentTime = $this->checkNullFormatDate($dtScheAfterCur[$i]->start, 'Y-m-d H:i:00');
                //                 $ShiftCurrentBreak = $dtScheAfterCur[$i]->break_times;
                //                 $EndShiftCurrentTime = $this->checkNullFormatDate($dtScheAfterCur[$i]->end, 'Y-m-d H:i:00');
                //             }
                //             if ( $StartShiftCurrentTime  < $CurrentDateTime )   $StartShiftCurrentTime = $CurrentDateTime;

                //             $NextCurDateTime = date( 'Y-m-d 00:00:00' , strtotime('+1 day' , strtotime ( $CurrentDate )));
                //             if ( $EndShiftCurrentTime >= $NextCurDateTime ) $EndShiftCurrentTime = $NextCurDateTime;
                //             //・Record件数 > 0 の場合は、残りの確定シフト時間を計算する。
                //             // $SubBreak = $this->subtractionTime($ShiftCurrentBreak, $rs["TodayUsedBreakTime"]);
                //             $SubBreak = (int) $ShiftCurrentBreak - (int) $rs["TodayUsedBreakTime"];
                //             if ( $SubBreak < 0) $SubBreak = 0;
                //             $hour = $this->calWorkTimeToBreak($StartShiftCurrentTime, $EndShiftCurrentTime, $SubBreak);
                //             $TodayShiftHour = $this->summationTime($TodayShiftHour, $hour);
                //         }
                //     }
                // } else {
                // //v.0.8.4
                // for ($j=0; $j < sizeof($ShopIDList); $j++) {
                //     if ($ShopIDList[$j]['FirstClockIn'] !== null) {
                //         $arrEmployee = [];
                //         array_push($arrEmployee, $ShopIDList[$j]['employee_id']);
                //         $dtScheBefor = $ScheduleTbl->getALLShiftScheDayBefore($arrEmployee, $ShopIDList[$j]["shop_id"], $CurrentDate, $CurrentDateTime, $SearchShiftType, $TotalType);
                //         if (sizeof($dtScheBefor) > 0) {
                //             for ($i=0; $i < sizeof($dtScheBefor); $i++) {
                //                 //・Record件数 > 0 の場合は、労働時間を計算する。
                //                 if ($TotalType == 'app' && $dtScheBefor[$i]->type === 'temp_shift') {
                //                     $ShiftBreak = $dtScheBefor[$i]->update_break_times;
                //                     $StartShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->update_start, 'Y-m-d H:i:00');
                //                     $EndShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->update_end, 'Y-m-d H:i:00');
                //                 } else {
                //                     $ShiftBreak = $dtScheBefor[$i]->break_times;
                //                     $StartShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->start, 'Y-m-d H:i:00');
                //                     $EndShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->end, 'Y-m-d H:i:00');
                //                 }

                //                 $start1 = $StartShiftTime;
                //                 $end1   = $CurrentDate . " 00:00:00";
                //                 $start2 = $end1;
                //                 $end2   = $EndShiftTime;
                //                 $break  = $ShiftBreak;
                //                 //当日の労働時間
                //                 $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                //                 //現在時間の残りシフト時間	←	EndShiftTime - CurrentDateTime
                //                 $timeRemaining = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                //                 if ($data["WorkHour"] < $timeRemaining) {
                //                     $DayBeforeShiftHour = $this->summationTime($DayBeforeShiftHour, $data["WorkHour"]);
                //                 } else {
                //                     $DayBeforeShiftHour = $this->summationTime($DayBeforeShiftHour, $timeRemaining);
                //                 }
                //             }
                //         }
                //     }
                // }
                // }
                //・現在時間以降の確定シフト時間を計算する。
                $ShiftHourOnTheDay = "00:00:00";
                for ($j=0; $j < sizeof($ShopIDList); $j++) {
                    if($ShopIDList[$j]['FirstClockIn'] !== null) {
                        $SumShiftHour = "00:00:00";
                        $dtScheShiftCur = $ScheduleTbl->getALLShiftScheDayCur($ShopIDList[$j]['employee_id'], $ShopIDList[$j]['shop_id'], $CurrentDate, $CurrentDateTime, null, $SearchShiftType, $TotalType);
                        if (sizeof($dtScheShiftCur) > 0) {
                            for ($i=0; $i < sizeof($dtScheShiftCur); $i++) {
                                if ($TotalType === 'app' && $dtScheShiftCur[$i]->type === 'temp_shift') {
                                    $StartShiftTime = $this->checkNullFormatDate($dtScheShiftCur[$i]->update_start, 'Y-m-d H:i:00');
                                    $ShiftBreak = $dtScheShiftCur[$i]->update_break;
                                    $EndShiftTime = $this->checkNullFormatDate($dtScheShiftCur[$i]->update_end, 'Y-m-d H:i:00');
                                } else {
                                    $StartShiftTime = $this->checkNullFormatDate($dtScheShiftCur[$i]->start, 'Y-m-d H:i:00');
                                    $ShiftBreak = $dtScheShiftCur[$i]->break;
                                    $EndShiftTime = $this->checkNullFormatDate($dtScheShiftCur[$i]->end, 'Y-m-d H:i:00');
                                }

                                $NextCurDateTime = date( 'Y-m-d 00:00:00' , strtotime('+1 day' , strtotime ( $CurrentDate )));

                                if ( $EndShiftTime >= $NextCurDateTime ) $EndShiftTime = $NextCurDateTime;

                                if ($StartShiftTime < $CurrentDateTime){
                                    $time1 = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                                    $time2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                    if($time1 >= $time2) {
                                        $ShiftHour = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, $ShiftBreak);
                                    } else {
                                        $ShiftHour = $time1;
                                    }
                                } else {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                }
                                // $SumShiftHour = date('H:i:s', strtotime($SumShiftHour) + strtotime($ShiftHour));
                                $SumShiftHour = $this->summationTime($SumShiftHour, $ShiftHour);
                            }
                        }
                        //ShiftHourOnTheDay (after the current time)
                        $ShiftHourOnTheDay = $this->summationTime($ShiftHourOnTheDay, $SumShiftHour);
                    }
                }

                //Shift時間を合算する。
                $rs["TodayShiftHour"] = $this->summationTime($DayBeforeShiftHour, $TodayShiftHour);
                $rs["TodayShiftHour"] = $this->summationTime($rs["TodayShiftHour"], $ShiftHourOnTheDay);

                //・労働時間と確定シフト時間を合算する。
                $rs["TargetDayWorkHour"] = $this->summationTime($rs["TodayShiftHour"] , $rs["TodayWorkHour"]);
            }
        }

        //・未連携店舗のシフト時間を計算する。
        //未連携店舗の場合、シフト時間から集計する。
        //---------------log start---------------------
        $this->writeLog28h('UserController', 'CalculateShiftWorkTime28Hour', '28 hour limit - 未連携店舗のシフト時間を計算する。', '', $CurrentDate, '');
        //---------------log end------------------------
        for ($j=0; $j < 7; $j++) {
            $TodayUserShift = "00:00:00";
            $arrUserDate = [
                "start" => date( 'Y-m-d', strtotime($PatternUser[$j]['start'])),
                "end" => date( 'Y-m-d', strtotime($PatternUser[$j]['end']))
            ];
            $dtUnlinkedShiftTimeDayStartEnd = $ScheduleTbl->getShiftUnlinkedShiftTimeDayStartEnd($userId, $arrUserDate['start'], $arrUserDate['end'], $isCheckDesignation);
            if (sizeof($dtUnlinkedShiftTimeDayStartEnd) > 0) {
                $NextPatternEnd = date( 'Y-m-d 00:00:00', strtotime('+1 days', strtotime($arrUserDate['end'])));
                for ($z=0; $z < sizeof($dtUnlinkedShiftTimeDayStartEnd); $z++) {
                    //・Record件数 > 0 の場合は、労働時間を計算する。
                    $StartUserShiftTime = $this->checkNullFormatDate($dtUnlinkedShiftTimeDayStartEnd[$z]->start, 'Y-m-d H:i:00');
                    $Break = $dtUnlinkedShiftTimeDayStartEnd[$z]->break_times;
                    $EndUserShiftTime = $this->checkNullFormatDate($dtUnlinkedShiftTimeDayStartEnd[$z]->end, 'Y-m-d H:i:00');
                    if($EndUserShiftTime > $NextPatternEnd){
                        $EndUserShiftTime = $NextPatternEnd;
                    }
                    $ShiftHour = $this->calWorkTimeToBreak($StartUserShiftTime, $EndUserShiftTime, $Break);
                    $TodayUserShift = $this->summationTime($TodayUserShift, $ShiftHour);
                }
            }
            $PatternUser[$j]["WorkHour"] = $this->summationTime($PatternUser[$j]["WorkHour"], $TodayUserShift);

            $dtUnlinkedShiftTimeDayBefore = $ScheduleTbl->getShiftUnlinkedShiftTimeDayBefore($userId, $arrUserDate['start'], $isCheckDesignation);
            if (sizeof($dtUnlinkedShiftTimeDayBefore) > 0) {
                for ($z=0; $z < sizeof($dtUnlinkedShiftTimeDayBefore); $z++) {
                    //・Record件数 > 0 の場合は、労働時間を計算する。
                    $StartUserShiftTime = $this->checkNullFormatDate($dtUnlinkedShiftTimeDayBefore[$z]->start, 'Y-m-d H:i:00');
                    $UserShiftBreak = $dtUnlinkedShiftTimeDayBefore[$z]->break_times;
                    $EndUserShiftTime = $this->checkNullFormatDate($dtUnlinkedShiftTimeDayBefore[$z]->end, 'Y-m-d H:i:00');

                    $start1 = $StartUserShiftTime;
                    $end1   = $PatternUser[$j]['start'];
                    $start2 = $end1;
                    $end2   = $EndUserShiftTime;
                    $break  = $UserShiftBreak;
                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                    $PatternUser[$j]["WorkHour"] = $this->summationTime($PatternUser[$j]["WorkHour"], $data["WorkHour"]);
                }
            }
        }

        //・過去、当日、未来の労働時間をPattern別に合算する。
        $Pattern = [];
        $FromDateMax = null;
        $ToDateMax = null;
        $MaxWorkHour = "00:00:00";
        //---------------log start---------------------
        $this->writeLog28h('UserController', 'CalculateShiftWorkTime28Hour', '28 hour limit - 過去、当日、未来の労働時間をPattern別に合算する。', '', $CurrentDate, '');
        //---------------log end------------------------
        for ($i=0; $i < 7; $i++) {

            $hour = "00:00:00";
            if ($CurrentDate . " 00:00:00" >= $PatternUser[$i]["start"] && $CurrentDate . " 00:00:00" <= $PatternUser[$i]["end"]) {
                $hour = $rs["TargetDayWorkHour"];
            }
            $hour = $this->summationTime($PatternPast[$i]["WorkHour"], $hour);
            $hour = $this->summationTime($hour, $PatternSchedule[$i]["WorkHour"]);
            $hour = $this->summationTime($hour, $PatternUser[$i]["WorkHour"]);
            $Pattern[$i] = $hour;
            //・Pattern1から7まで最大の労働時間を取得する。
            //MaxWorkHour	←	Max (Pattern[])
            if ($this->parseHourToSeconds($MaxWorkHour) < $this->parseHourToSeconds($Pattern[$i])) {
                $MaxWorkHour = $Pattern[$i];
                $FromDateMax = $PatternUser[$i]["start"];
                $ToDateMax   = $PatternUser[$i]["end"];
            }
        }
        $rs["RemainingTimeLimit"] = $MaxWorkHour;
        $rs["FromDateMax"] = $FromDateMax;
        $rs["ToDateMax"] = $ToDateMax;

        return  $rs;
    }
