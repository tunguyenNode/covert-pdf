<?php
public function CalculateShiftWorkTime28Hour ($UserEmployIDList, $mergeShopID,
                                              $LatestWorkID, $LatestWorkStartTime, $LatestWorkEndTime,
                                              $LatestStartBreakTime, $LatestBreak, $CurrentDate, $CurrentDateTime,
                                              $ShopIDList,$_28CheckStartDate, $_28CheckEndDate, $TargetDate, $LatestWorkShopID,
                                              $user_Id, $isCheckDesignation, $SearchShiftType, $TotalType) {
    $rs["TodayWorkHour"] = '00:00:00'; // Thời gian làm việc hôm nay
    $rs["TodayShiftHour"] = '00:00:00'; // Thời gian ca làm hôm nay
    $rs["PreviousDayUsedBreakTime"] = '00:00:00'; // Thời gian nghỉ đã sử dụng ngày trước
    $rs["ClockIn"] = ''; // Thời gian chấm công vào
    $rs["TargetDayWorkHour"] = "00:00:00"; // Thời gian làm việc ngày mục tiêu
    $rs["RemainingTimeLimit"] = "00:00:00"; // Thời gian còn lại trong giới hạn
    $rs["FromDateMax"] = "00:00:00"; // Thời gian tối đa từ ngày bắt đầu
    $rs["ToDateMax"] = "00:00:00"; // Thời gian tối đa đến ngày kết thúc


    $TodayWorkHour = "00:00:00"; // Khởi tạo biến $TodayWorkHour để lưu thời gian làm việc trong ngày hiện tại, mặc định là 00:00:00.


    $AttendanceTbl = $this->getTableLocator()->get('Attendance'); // Lưu trữ thông tin chấm công thực tế của nhân viên (thời gian vào/ra).
    $ScheduleTbl = $this->getTableLocator()->get('Schedule'); // Lưu trữ lịch làm việc dự kiến (thời gian ca làm, thời gian nghỉ).

    $LatestWorkStart = null;  // Khởi tạo biến $LatestWorkStart
    $LatestWorkEnd = null; // Khởi tạo biến $LatestWorkEnd

    $userId = $user_Id;

    //・Tính giờ làm việc của ngày hôm trước.
    if (!is_null($LatestWorkStartTime)) {
        //LatestWorkStartTime?Date
        // Mục đích: Nếu $LatestWorkStartTime không null, chuyển nó thành định dạng ngày YYYY-MM-DD.
        $LatestWorkStart = date('Y-m-d', strtotime($LatestWorkStartTime));
    }

    if (!is_null($LatestWorkEndTime)) {
        //LatestWorkEndTime?Date
        // Mục đích: Tương tự, chuyển $LatestWorkEndTime thành định dạng ngày YYYY-MM-DD nếu không null.
        $LatestWorkEnd = date('Y-m-d', strtotime($LatestWorkEndTime));
    }
    $TotalWorkHour = "00:00:00";
    
    
    // Tính ngày trước $CurrentDate và gán vào $preCurrentDate.
    // Dùng để xử lý dữ liệu của ngày hôm trước, ví dụ: nếu $CurrentDate là 2025-06-16, thì $preCurrentDate là 2025-06-15.
    $preCurrentDate= date('Y-m-d' , strtotime('-1 day', strtotime ($CurrentDate)));


    // Khởi tạo ba mảng rỗng để lưu trữ các mẫu thời gian kiểm tra.
    $PatternPast = []; // $PatternPast: Lưu các khoảng thời gian trong quá khứ (trước $CurrentDate), dựa trên dữ liệu chấm công.
    $PatternSchedule = []; // $PatternSchedule: Lưu các khoảng thời gian trong tương lai (sau $CurrentDate), dựa trên lịch trình.
    $PatternUser = []; // $PatternUser: Lưu các khoảng thời gian tổng quát, bao gồm cả quá khứ và tương lai.
    
    
    //    Tạo các mẫu thời gian (vòng lặp $j)
    // Tạo 7 mẫu thời gian khác nhau, mỗi mẫu đại diện cho một khoảng thời gian trượt từ 6 ngày trước đến 6 ngày sau $TargetDate.
    for ($j=0; $j < 7; $j++) {
        // Mục đích: Tính số ngày trước $TargetDate để xác định thời gian bắt đầu của mẫu.
        // Ví dụ: Khi $j = 0, $num = 6 (6 ngày trước); khi $j = 6, $num = 0 (ngày $TargetDate).
        $num = 6 - $j;
        // : Tính thời gian bắt đầu ($start) và kết thúc ($end) của mẫu thời gian.
        // Ví dụ: Nếu $TargetDate = 2025-06-16, $j = 0, $num = 6 → $start = 2025-06-10 00:00:00, $end = 2025-06-16 00:00:00.
        $start = date( 'Y-m-d 00:00:00', strtotime('-'. (int) $num .' day' , strtotime ( $TargetDate))); // $start: Ngày cách $TargetDate $num ngày về trước, định dạng YYYY-MM-DD 00:00:00.
        $end = date( 'Y-m-d 00:00:00', strtotime('+ '.$j.' day' , strtotime ( $TargetDate ))); // $end: Ngày cách $TargetDate $j ngày về sau, định dạng YYYY-MM-DD 00:00:00.

        
        // Mục đích: Tạo khoảng thời gian cho $PatternUser, đảm bảo nằm trong giới hạn $_28CheckStartDate và $_28CheckEndDate.
        $startUser = ( $start < $_28CheckStartDate . " 00:00:00" ) ?  $_28CheckStartDate  . " 00:00:00" : $start; // $startUser: Nếu $start sớm hơn $_28CheckStartDate, lấy $_28CheckStartDate; nếu không, giữ $start.
        $endUser = ($_28CheckEndDate . " 00:00:00"  < $end) ? $_28CheckEndDate  . " 00:00:00" : $end; // $endUser: Nếu $end muộn hơn $_28CheckEndDate, lấy $_28CheckEndDate; nếu không, giữ $end.
        // $arrUser: Mảng chứa start và end cho mẫu $PatternUser.
        $arrUser = [
            "start" => $startUser,
            "end" => $endUser
        ];

        
        // Mục đích: Tạo khoảng thời gian cho $PatternPast, tập trung vào dữ liệu quá khứ (trước $CurrentDate).
        // $startPast: Nếu $start sớm hơn $_28CheckStartDate, lấy $_28CheckStartDate; nếu không, giữ $start.
        $startPast = ($start < $_28CheckStartDate . " 00:00:00") ? $_28CheckStartDate . " 00:00:00" : $start;
        // $endPast: Nếu $end từ $CurrentDate trở đi, lấy ngày trước $CurrentDate; sau đó kiểm tra không muộn hơn $_28CheckEndDate.
        $endPast = ($end >= $CurrentDate . " 00:00:00") ? date('Y-m-d 00:00:00', strtotime('-1 day', strtotime($CurrentDate))) : $end; 
        $endPast = ($_28CheckEndDate . " 00:00:00" < $endPast) ? $_28CheckEndDate . " 00:00:00" : $endPast;
        // $arrPast: Mảng chứa start và end cho mẫu $PatternPast.
        $arrPast = [
            "start" => $startPast,
            "end" => $endPast
        ];

        // Mục đích: Tạo khoảng thời gian cho $PatternSchedule, tập trung vào lịch trình tương lai (sau $CurrentDate).
        
        // $startSchedule: Nếu $start trước hoặc bằng $CurrentDate, lấy ngày sau $CurrentDate; sau đó kiểm tra không sớm hơn $_28CheckStartDate.
        $startSchedule = ( $start <= $CurrentDate . " 00:00:00" ) ? date('Y-m-d 00:00:00' , strtotime('+1 day', strtotime ($CurrentDate))) : $start;
        $startSchedule = ($startPast < $_28CheckStartDate . " 00:00:00" ) ? $_28CheckStartDate  . " 00:00:00"  : $startSchedule;
        // $endSchedule: Nếu $end muộn hơn $_28CheckEndDate, lấy $_28CheckEndDate; nếu không, giữ $end.
        $endSchedule = ($_28CheckEndDate . " 00:00:00"  < $end) ? $_28CheckEndDate  . " 00:00:00"  : $end;
        //  $arrSchedule: Mảng chứa start, end, và flg_schedule.
        $arrSchedule = [
            "start" => $startSchedule,
            "end" => $endSchedule,
            "flg_schedule" => ($startSchedule > $endSchedule) ? false : true // flg_schedule: Cờ kiểm tra tính hợp lệ của khoảng thời gian (nếu $startSchedule > $endSchedule, đặt là false).
        ];

        // Mục đích: Thêm các mảng $arrPast, $arrSchedule, $arrUser vào các mảng mẫu tương ứng.
        array_push($PatternPast, $arrPast);
        array_push($PatternSchedule, $arrSchedule);
        array_push($PatternUser, $arrUser);
        
        //Mục đích: Khởi tạo thời gian làm việc (WorkHour) cho mỗi mẫu là 00:00:00, sẽ được cập nhật sau khi tính toán.
        $PatternPast[$j]["WorkHour"] = "00:00:00";
        $PatternSchedule[$j]["WorkHour"] = "00:00:00";
        $PatternUser[$j]["WorkHour"] = "00:00:00";
    }

    // Mục đích: Kiểm tra xem $UserEmployIDList có chứa dữ liệu không.
    // Giải thích: Nếu danh sách ID nhân viên không rỗng, tiếp tục xử lý; nếu rỗng, bỏ qua vòng lặp bên dưới.
    if (sizeof($UserEmployIDList) !== 0) {
        //---------------log end------------------------
        // Mục đích: Lặp qua danh sách các cửa hàng ($ShopIDList) để tính thời gian làm việc tại từng cửa hàng.											
        for ($i=0; $i < sizeof($ShopIDList); $i++) {
            
            // Mục đích: Lấy thời gian chấm công lần đầu (FirstClockIn) của nhân viên tại cửa hàng thứ $i.
            // FirstClockIn là trường trong $ShopIDList[$i], cho biết nhân viên đã chấm công hay chưa.
            $FirstClockIn = $ShopIDList[$i]["FirstClockIn"];
           
            // Mục đích: Kiểm tra xem nhân viên đã chấm công tại cửa hàng này chưa.
            // Giải thích: Nếu FirstClockIn là null, nghĩa là chưa có dữ liệu chấm công, hàm sẽ sử dụng lịch trình từ $ScheduleTbl.
            if(is_null($FirstClockIn)){
                // Mục đích: Lặp lại 7 mẫu thời gian để tính thời gian làm việc dựa trên lịch trình.
                for ($j=0; $j < 7; $j++) {
                    
                    // Mục đích: Tính lại thời gian bắt đầu và kết thúc cho mẫu thời gian hiện tại (tương tự vòng lặp $j đầu tiên).
                    $num = 6 - $j;
                    $start = date( 'Y-m-d 00:00:00', strtotime('-'. (int) $num .' day' , strtotime ( $TargetDate)));
                    $end = date( 'Y-m-d 00:00:00', strtotime('+ '.$j.' day' , strtotime ( $TargetDate )));

                    // Mục đích: Trích xuất ngày từ $startPattern và $endPattern để sử dụng trong truy vấn lịch trình.
                    // Giải thích: Chỉ lấy phần ngày (YYYY-MM-DD) để truy vấn $ScheduleTbl.
                    $startPattern = ( $start < $_28CheckStartDate . " 00:00:00" ) ?  $_28CheckStartDate  . " 00:00:00" : $start;
                    $endPattern = ($_28CheckEndDate . " 00:00:00"  < $end) ? $_28CheckEndDate  . " 00:00:00" : $end;

                    $StartShift	= date( 'Y-m-d', strtotime($startPattern));
                    $EndShift	= date( 'Y-m-d', strtotime($endPattern));

                    if ($_28CheckStartDate > $CurrentDate) {
                        if (!$PatternSchedule[$j]['flg_schedule']) continue;

                        $dtSch = $ScheduleTbl->getShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $SearchShiftType, $TotalType);
                        $total = "00:00:00";
                        foreach ($dtSch as $key => $value) {
                            if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                $Break = $value["update_break"];
                                $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                            } else {
                                $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                $Break = $value["break"];
                                $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                            }

                            $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                            //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                            if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                                $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                            } else {
                                $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                            }
                            $total = $this->summationTime($total, $ShiftHour);
                        }
                        //PatternSchedule[]		←		SUM(ShiftHour)				
                        $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                        $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                        //・対象期間開始日の前日からの確定シフト時間
                        $dtSch = $ScheduleTbl->getShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                        $total = "00:00:00";
                        foreach ($dtSch as $key => $value) {
                            if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                $DayBeforeBreak = $value["update_break"];
                                $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                            } else {
                                $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                $DayBeforeBreak = $value["break"];
                                $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                            }

                            $start1 = $DayBeforeStartShiftTime;
                            $end1   = $StartShift . " 00:00:00";
                            $start2 = $end1;
                            $end2   = $DayBeforeEndShiftTime;
                            $break  = $DayBeforeBreak;
                            //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //集計項目
                            $total = $this->summationTime($total, $data["WorkHour"]);
                        }
                        //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間									
                        $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                    }
                    //・過去+未来の労働時間を計算する。
                    // ・チェック対象期間内に現在日が存在する場合 ( 28CheckStartDate <= CurrentDate <= 28CheckEndDate の場合)
                    if($_28CheckStartDate <= $CurrentDate && $CurrentDate <= $_28CheckEndDate) {
                        $StartShiftDatePattern	= date( 'Y-m-d', strtotime($startPattern));
                        $EndShiftDatePattern	= date( 'Y-m-d', strtotime($endPattern));
                        //・Pattern1-7の対象期間開始日から、CurrentDateまでのシフト時間を集計する。 ( PatternSchedule[] の開始日 <=  CurrentDate <= PatternSchedule[] の終了日 の場合)
                        if ($StartShiftDatePattern <= $CurrentDate && $CurrentDate <= $EndShiftDatePattern) {
                          
                            //・ CurrentDateTime から、Pattern1-7の対象期間開始日 までのシフト時間を集計する。
                            $StartShift	= $preCurrentDate;
                            $EndShift	= date('Y-m-d', strtotime($endPattern));

                            $dtSch = $ScheduleTbl->getALLShiftPastNolink($ShopIDList[$i], $StartShift, $EndShift, $CurrentDateTime, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $Break = $value["update_break_times"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $Break = $value["break_times"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }
                                // $typeShift = $value["type"];
                                $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                                $EndShiftTime = (  $EndShiftTime >= $EndShiftNext . " 00:00:00" ) ? $EndShiftNext . " 00:00:00" : $EndShiftTime;
                                if ( date( 'Y-m-d', strtotime($StartShiftTime)) === $StartShift ) {
                                    //< (CurrentDateTime - StartShiftTime)の分 <= Break >
                                    $total1  = $this->calWorkTimeToBreak($StartShiftTime, $CurrentDateTime, 0);
                                    if ((int) $this->parseTimeToMin($total1) <= (int) $Break) {
                                        $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                    } else {
                                        $ShiftHour = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                                    }
                                } else {
                                    //<  StartShiftTime < CurrentDateTime の場合 >
                                    if ($StartShiftTime < $CurrentDateTime) {
                                        //<  ( EndShiftTime - CurrentDateTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合>
                                        $total1  = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                                        $total2  = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                        if ($total1 >= $total2) {
                                            $ShiftHour = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, $Break);
                                        } else {
                                            $ShiftHour = $total1;
                                        }
                                    } else {
                                        $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                    }
                                }
                                $total = $this->summationTime($total, $ShiftHour);
                            }
                            //PatternSchedule[]		←		SUM(ShiftHour)				
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                        }
                        //・CurrentDate < PatternSchedule[] の開始日 の場合
                        if ($CurrentDate < $StartShiftDatePattern) {
                            $StartShift	= date( 'Y-m-d', strtotime($startPattern));
                            $EndShift	= date( 'Y-m-d', strtotime($endPattern));

                            $dtSch = $ScheduleTbl->getShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $Break = $value["update_break"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $Break = $value["break"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }

                                $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                                // //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                                if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                                } else {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                }
                                $total = $this->summationTime($total, $ShiftHour);
                            }
                            //PatternSchedule[]		←		SUM(ShiftHour)				
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                            $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                            //・対象期間開始日の前日からの確定シフト時間
                            $dtSch = $ScheduleTbl->getShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $DayBeforeBreak = $value["update_break"];
                                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $DayBeforeBreak = $value["break"];
                                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }
                                $start1 = $DayBeforeStartShiftTime;
                                $end1   = $StartShift . " 00:00:00";
                                $start2 = $end1;
                                $end2   = $DayBeforeEndShiftTime;
                                $break  = $DayBeforeBreak;
                                //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //集計項目
                                $total = $this->summationTime($total, $data["WorkHour"]);
                            }
                            //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間									
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                        }
                      
                    }
                }
            }
            //・過去の労働時間を計算する。 ( FirstClockIn != null の場合 )
            else{
                $FirstClockInDate = date('Y-m-d', strtotime($FirstClockIn));
                // //・チェック対象期間が現在日より前の場合 ( 28CheckEndDate < CurrentDate AND FirstClockInのDate <= 28CheckEndDate の場合 )
                // if($_28CheckEndDate < $CurrentDate && $FirstClockInDate <= $_28CheckEndDate){
                //・チェック対象期間が現在日より前の場合 ( 28CheckEndDate < CurrentDate の場合 ) v.0.7.8
                if($_28CheckEndDate < $CurrentDate){
                    //・連携店舗の労働時間を計算する。
                    for ($j=0; $j < 7; $j++) {
                        $StartShift	= date( 'Y-m-d', strtotime($PatternPast[$j]["start"]));
                        $EndShift	= date( 'Y-m-d', strtotime($PatternPast[$j]["end"]));
                        //・連携店舗の労働時間
                        //長期休暇が存在するため、28CheckStartDateまたは28CheckEndDate が Pattern1-6 の期間と一致しない場合があるため、長期休暇日を集計しないように注意すること。
                        $TotalWorkHour28h = "00:00:00";
                        $PatternPastEndNext = date( 'Y-m-d 00:00:00', strtotime('+1 day' , strtotime ( $PatternPast[$j]['end'] )));
                        $dtAtten = $AttendanceTbl->getShiftAttendance28h($ShopIDList[$i], $PatternPast[$j]);
                        foreach ($dtAtten as $key => $value) {
                            $StartWorkTime =  $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                            // $dtBreak = $value["break_times"];
                            $Break = $value["break_times"];
                            $date = $this->checkNullFormatDate($value["date"], 'Y-m-d');
                            if ( $date === $preCurrentDate ) {
                                $Break = (is_null($Break)) ? $LatestBreak : $Break;
                            }
                            $Break = (is_null($Break)) ? 0 : $Break;
                            // $EndWorkTime =  $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                            $endTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                            $EndWorkTime = (is_null($endTime)) ? $CurrentDateTime : $endTime ;

                            //IF(EndWorkTime > CurrentDate + ' 00:00:00', CurrentDate + ' 00:00:00',  EndWorkTime) - StartWorkTime - Break
                            if ($EndWorkTime > $PatternPastEndNext) {
                                $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $PatternPastEndNext, $Break);
                            } else {
                                $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $EndWorkTime, $Break);
                            }
                            //集計項目
                            $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $WorkHour);
                        }
                        //PatternPast[]	← SUM(WorkHour)	
                        $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $TotalWorkHour28h);

                        //・Pattern1-7の対象期間開始日の前日からの労働時間
                        $arrTimePattern = [
                            "start" => $StartShift,
                            "end" => $EndShift
                        ];
                        $dtAttenPre = $AttendanceTbl->getShiftAttendancePreDay($ShopIDList[$i], $arrTimePattern);
                        $TotalWorkHour28h = "00:00:00";
                        foreach ($dtAttenPre as $key => $value) {
                            //・Record件数 > 0 の場合は、労働時間を計算する。
                            $DayBeforeStartWorkTime = $this->checkNullFormatDate($value->start,'Y-m-d H:i:00');
                            $DayBeforeStartBreak = $value->break;
                            $DayBeforeEndWorkTime = $this->checkNullFormatDate($value->end,'Y-m-d H:i:00');

                            $start1 = $DayBeforeStartWorkTime;
                            $end1   = $StartShift . " 00:00:00";
                            $start2 = $end1;
                            $end2   = $DayBeforeEndWorkTime;
                            $break  = $DayBeforeStartBreak;
                            //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //集計項目
                            $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $data["WorkHour"]);
                        }
                        //PatternPast[]	 ←	PatternPast[] + 計算した労働時間								
                        $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $TotalWorkHour28h);
                        //・連携店舗の確定シフト時間を計算する。
                        //・PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日の場合の集計処理を行う。
                        if( $StartShift <= $FirstClockInDate && $FirstClockInDate <= $EndShift ){
                            //Pattern1-7（-6日から+6日までのPattern）分を取得する。
                            //PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日
                            //・対象期間に最初の打刻日が含まれる場合は最初の打刻日の1日前まで集計する。（ PatternPast[] の開始日 < FirstClockInのDate <= PatternPast[] の終了日 の場合）
                            $FirstClockInPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $FirstClockInDate )));
                            // Delete v.0.12.0
                            // if( $StartShift < $FirstClockInDate && $FirstClockInDate <= $EndShift ){
                            //     // $FirstClockInPreDate = date( 'Y-m-d', strtotime($FirstClockInPre));
                            //     $dtScheduleShift = $ScheduleTbl->getALLShiftScheduleShiftPattern($ShopIDList[$i], $StartShift, $FirstClockInPre, $AppNotStampedShiftType);
                            //     $ShiftHour = "00:00:00";
                            //     foreach ($dtScheduleShift as $key => $value) {
                            //         if ($value["type"] === 'temp_shift') {
                            //             $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                            //             $Break  = $value->update_break;
                            //             $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                            //         } else {
                            //             $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //             $Break  = $value->break;
                            //             $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                            //         }
                            //         if ( $EndShiftTime > ($FirstClockInDate . " 00:00:00")) {
                            //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockInDate . " 00:00:00", $Break);
                            //         } else {
                            //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                            //         }				
                            //         $ShiftHour = $this->summationTime($ShiftHour, $hour);
                            //     }
                            //     //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)		
                            //     $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $ShiftHour);

                            //     //Pattern1-7の対象期間開始日の前日からのシフト時間を集計する。
                            //     $dtSchedulePre = $ScheduleTbl->getALLShiftScheduleShiftTarget($ShopIDList[$i], $StartShift, $AppNotStampedShiftType);
                            //     $totalHour = "00:00:00";
                            //     foreach ($dtSchedulePre as $key => $value) {
                            //         if ($value->type === 'temp_shift') {
                            //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                            //             $DayBeforeBreak = $value->update_break;
                            //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                            //         } else {
                            //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //             $DayBeforeBreak = $value->break;
                            //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                            //         }

                            //         $start1 = $DayBeforeStartShiftTime;
                            //         $end1   = $StartShift . " 00:00:00";
                            //         $start2 = $end1;
                            //         $end2   = $DayBeforeEndShiftTime;
                            //         $break  = $DayBeforeBreak;
                            //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //         //集計項目
                            //         $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                            //     }
                            //     //PatternPast[]	←	PatternPast[] + 計算した労働時間	
                            //     $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);
                            // }
                            //・Pattern1-7の最初の打刻日の前日から打刻日時以前の確定シフト時間を集計する。 ( PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日 の場合)
                            // if( $StartShift <= $FirstClockInDate && $FirstClockInDate <= $EndShift ){
                            //     //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                            //     $totalHour = "00:00:00";
                            //     //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                            //     $dtSchedule = $ScheduleTbl->getALLScheduleShiftFirstClockIn($ShopIDList[$i], $FirstClockInPre, $FirstClockInDate, $AppNotStampedShiftType);
                            //     foreach ($dtSchedule as $key => $value) {
                            //         if ($value->type === 'temp_shift') {
                            //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                            //             $DayBeforeBreak = $value->update_break;
                            //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                            //         } else {
                            //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //             $DayBeforeBreak = $value->break;
                            //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');    
                            //         }

                            //         $start1 = $DayBeforeStartShiftTime;
                            //         $end1   = $FirstClockInDate . " 00:00:00";
                            //         $start2 = $end1;
                            //         $end2   = $DayBeforeEndShiftTime;
                            //         $break  = $DayBeforeBreak;
                            //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //         //最初の打刻が、シフト時間内の場合、シフト時間から、その差分を引く。
                            //         //< DayBeforeEndShiftTime <= ShopIDList[].FirstClockIn の場合 >															
                            //         if ( $DayBeforeEndShiftTime <= $FirstClockIn) {
                            //             //PatternPast[]		←	PatternPast[] + 当日労働時間の計算結果							
                            //             $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                            //         } else {
                            //             //< DayBeforeEndShiftTime > ShopIDList[].FirstClockIn の場合 >
                            //             //PatternPast[] + 当日労働時間の計算結果 -  ( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )	
                            //             //PatternPast[] + 当日労働時間の計算結果
                            //             $hourstart = $this->summationTime($totalHour, $data["WorkHour"]);
                            //             //( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
                            //             $ShiftTime = Chronos::parse($DayBeforeEndShiftTime);
                            //             $FirstClockInShift = Chronos::parse($FirstClockIn);
                            //             $diff = $FirstClockInShift->diff($ShiftTime);
                            //             $hourend = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                            //             if ($hourstart > $hourend) $totalHour = $this->subtractionTime($hourstart, $hourend);			
                            //         }
                            //     }
                            //     $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);

                            //     //・FirstClockInの日で最初の打刻以前の確定シフト時間を計算する。
                            //     $dtSchedule = $ScheduleTbl->getScheduleALLShiftTimeFirstClockIn($ShopIDList[$i], $FirstClockInDate . " 00:00:00", $FirstClockIn, $AppNotStampedShiftType);
                            //     $ShiftHour = "00:00:00";
                            //     $SumShiftHour = "00:00:00";
                            //     foreach ($dtSchedule as $key => $value) {
                            //         if ($value->type === 'temp_shift') {
                            //             $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                            //             $ShiftBreak = $value->update_break;
                            //             $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                            //         } else {
                            //             $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                            //             $ShiftBreak = $value->break;
                            //             $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                            //         }
                            //         if ($EndShiftTime <= $FirstClockIn) {
                            //             $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                            //         } else {
                            //             // ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合
                            //             $StartShiftTime = Chronos::parse($StartShiftTime);
                            //             $FirstClockInShift = Chronos::parse($FirstClockIn);
                            //             $diff = $FirstClockInShift->diff($StartShiftTime);
                            //             $time1 = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                            //             $time2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                            //             //<  ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合>
                            //             if ( $time1 >= $time2 ) {
                            //                 //最初の打刻以前の労働時間が予定シフト時間以上の場合、休憩時間は取得済みとして計算する。
                            //                 $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockIn, $ShiftBreak);
                            //             } else {
                            //                 $ShiftHour = $time1;
                            //             }
                            //         }
                            //         $SumShiftHour = $this->summationTime($SumShiftHour, $ShiftHour);
                            //     }
                            //     //PatternPast[]	←	PatternPast[] + 計算した労働時間	
                            //     $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $SumShiftHour);
                            // }
                        }
                        // Delete v.0.12.0
                        //28 hours limit(過去初回打刻日より前)
                        //・PatternPast[] の終了日 < FirstClockInのDate の場合の集計処理を行う。
                        // if ( $EndShift < $FirstClockInDate) {
                        //     $dtScheduleShift = $ScheduleTbl->getALLShiftScheduleShiftPattern($ShopIDList[$i], $StartShift, $EndShift, $AppNotStampedShiftType);
                        //     $ShiftHour = "00:00:00";
                        //     foreach ($dtScheduleShift as $key => $value) {
                        //         if ($value["type"] === 'temp_shift') {
                        //             $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                        //             $Break  = $value->update_break;
                        //             $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                        //         } else {
                        //             $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                        //             $Break  = $value->break;
                        //             $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                        //         }

                        //         $EndNextDate = date( 'Y-m-d', strtotime('+1 day' , strtotime ( $EndShift )));

                        //         if ( $EndShiftTime > ($EndNextDate . " 00:00:00")) {
                        //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndNextDate . " 00:00:00", $Break);
                        //         } else {
                        //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                        //         }				
                        //         $ShiftHour = $this->summationTime($ShiftHour, $hour);
                        //     }
                        //     //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)		
                        //     $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $ShiftHour);

                        //     //Pattern1-7の対象期間開始日の前日からのシフト時間を集計する。
                        //     $dtSchedulePre = $ScheduleTbl->getALLShiftScheduleShiftTarget($ShopIDList[$i], $StartShift, $AppNotStampedShiftType);
                        //     $totalHour = "00:00:00";
                        //     foreach ($dtSchedulePre as $key => $value) {
                        //         if ($value->type === 'temp_shift') {
                        //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                        //             $DayBeforeBreak = $value->update_break;
                        //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                        //         } else {
                        //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                        //             $DayBeforeBreak = $value->break;
                        //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                        //         }
                        //         $start1 = $DayBeforeStartShiftTime;
                        //         $end1   = $StartShift . " 00:00:00";
                        //         $start2 = $end1;
                        //         $end2   = $DayBeforeEndShiftTime;
                        //         $break  = $DayBeforeBreak;
                        //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                        //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                        //         //集計項目
                        //         $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                        //     }
                        //     //PatternPast[]	←	PatternPast[] + 計算した労働時間	
                        //     $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);
                        // }
                    }
                }
                //・未来の労働時間を計算する。 
                //・チェック対象期間が現在日よりあとの場合 ( 28CheckStartDate > CurrentDate の場合)
                if($_28CheckStartDate > $CurrentDate){
                    for ($j=0; $j < 7; $j++) {
                        if (!$PatternSchedule[$j]['flg_schedule']) continue;
                        $StartShift	= date( 'Y-m-d', strtotime($PatternSchedule[$j]["start"]));
                        $EndShift	= date( 'Y-m-d', strtotime($PatternSchedule[$j]["end"]));

                        $dtSch = $ScheduleTbl->getShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $SearchShiftType, $TotalType);
                        $total = "00:00:00";
                        foreach ($dtSch as $key => $value) {
                            if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                $Break = $value["update_break"];
                                $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                            } else {
                                $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                $Break = $value["break"];
                                $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                            }

                            $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                            //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                            if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                                $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                            } else {
                                $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                            }
                            $total = $this->summationTime($total, $ShiftHour);
                        }
                        //PatternSchedule[]		←		SUM(ShiftHour)				
                        $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                        $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                        //・対象期間開始日の前日からの確定シフト時間
                        $dtSch = $ScheduleTbl->getShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                        $total = "00:00:00";
                        foreach ($dtSch as $key => $value) {
                            if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                $DayBeforeBreak = $value["update_break"];
                                $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                            } else {
                                $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                $DayBeforeBreak = $value["break"];
                                $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                            }

                            $start1 = $DayBeforeStartShiftTime;
                            $end1   = $StartShift . " 00:00:00";
                            $start2 = $end1;
                            $end2   = $DayBeforeEndShiftTime;
                            $break  = $DayBeforeBreak;
                            //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                            $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //集計項目
                            $total = $this->summationTime($total, $data["WorkHour"]);
                        }
                        //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間									
                        $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                    }
                }

                //・過去+未来の労働時間を計算する。
                if($_28CheckStartDate <= $CurrentDate && $CurrentDate <= $_28CheckEndDate){
                    //チェック対象期間内に存在するCurrentDateの1日前までを過去の労働時間として集計する。
                    //・Pattern1-7の対象期間開始日から、CurrentDate -1日までの労働時間を集計する。 ( PatternPast[] の開始日 <  CurrentDate の場合)
                    for ($j=0; $j < 7; $j++) {
                        $StartShift	= date( 'Y-m-d', strtotime($PatternPast[$j]["start"]));
                        $EndShift	= date( 'Y-m-d', strtotime($PatternPast[$j]["end"]));
                        //「・過去の労働時間を計算する。」
                        // if(!is_null($FirstClockIn)){
                        if($PatternPast[$j]['start'] < $CurrentDate.' 00:00:00'){
                            // if($PatternPast[$j]['end'] < $CurrentDate.' 00:00:00'){
                            //     $Today = $PatternPast[$j]['end'];
                            // }else{
                            //     $Today = date( 'Y-m-d 00:00:00' , strtotime('-1 day' , strtotime ( $CurrentDate )));
                            // }
                            //・連携店舗の労働時間
                            //長期休暇が存在するため、28CheckStartDateまたは28CheckEndDate が Pattern1-6 の期間と一致しない場合があるため、長期休暇日を集計しないように注意すること。
                            $TotalWorkHour28h = "00:00:00";
                            $PatternPastEnd = date( 'Y-m-d 00:00:00', strtotime('+1 day' , strtotime ( $PatternPast[$j]['end'] )));
                            $arrTimePattern = [
                                "start" => $PatternPast[$j]["start"],
                                "end" => $PatternPast[$j]["end"]
                            ];
                            $dtAtten = $AttendanceTbl->getShiftAttendance28h($ShopIDList[$i], $arrTimePattern);
                            foreach ($dtAtten as $key => $value) {
                                $StartWorkTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                // $Break =  $value["break_times"];
                                // $EndWorkTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                $Break = $value["break_times"];
                                $date = $this->checkNullFormatDate($value["date"], 'Y-m-d');
                                if ( $date === $preCurrentDate ) {
                                    $Break = (is_null($Break)) ? $LatestBreak : $Break;
                                }
                                $Break = (is_null($Break)) ? 0 : $Break;
                                // $EndWorkTime =  $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                $endTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                $EndWorkTime = (is_null($endTime)) ? $CurrentDateTime : $endTime ;

                                //IF(EndWorkTime > ToDay + 1day + ' 00:00:00', ToDay + 1day + ' 00:00:00',  EndWorkTime) - StartWorkTime - Break
                                if ($EndWorkTime > $PatternPastEnd) {
                                    $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $PatternPastEnd, $Break);
                                } else {
                                    $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $EndWorkTime, $Break);
                                }
                                //集計項目
                                $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $WorkHour);
                            }
                            //PatternPast[]	← SUM(WorkHour)	
                            $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $TotalWorkHour28h);

                            //・Pattern1-7の対象期間開始日の前日からの労働時間
                            $arrTimePattern = [
                                "start" => $StartShift,
                                "end" => $EndShift
                            ];
                            $dtAttenPre = $AttendanceTbl->getShiftAttendancePreDay($ShopIDList[$i], $arrTimePattern);
                            $TotalWorkHour28h = "00:00:00";
                            foreach ($dtAttenPre as $key => $value) {
                                //・Record件数 > 0 の場合は、労働時間を計算する。
                                $DayBeforeStartWorkTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                $DayBeforeStartBreak = $value->break;
                                $DayBeforeEndWorkTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');

                                $start1 = $DayBeforeStartWorkTime;
                                $end1   = $PatternPast[$j]["start"];
                                $start2 = $end1;
                                $end2   = $DayBeforeEndWorkTime;
                                $break  = $DayBeforeStartBreak;
                                //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //集計項目
                                $TotalWorkHour28h = $this->summationTime($TotalWorkHour28h, $data["WorkHour"]);
                            }
                            //PatternPast[]	 ←	PatternPast[] + 計算した労働時間								
                            $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $TotalWorkHour28h);
                            if(!is_null($FirstClockIn)){
                                //Delete v.0.12.0
                                //・PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日の場合の集計処理を行う。
                                // if( $StartShift <= $FirstClockInDate && $FirstClockInDate <= $EndShift) { 
                                //     //Pattern1-7（-6日から+6日までのPattern）分を取得する。
                                //     //PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日
                                //     //・対象期間に最初の打刻日が含まれる場合は最初の打刻日の1日前まで集計する。（ PatternPast[] の開始日 < FirstClockInのDate <= PatternPast[] の終了日 の場合）
                                //     $FirstClockInPre = date( 'Y-m-d', strtotime('-1 day' , strtotime ( $FirstClockInDate )));
                                //     // $TodayDate= date( 'Y-m-d', strtotime ( $PatternPast[$j]['end'] ));
                                //     if( $StartShift < $FirstClockInDate && $FirstClockInDate <= $EndShift){
                                //         // $EndShift = date( 'Y-m-d', strtotime($FirstClockInPre));
                                //         $dtScheduleShift = $ScheduleTbl->getALLShiftScheduleShiftPattern($ShopIDList[$i], $StartShift, $FirstClockInPre, $AppNotStampedShiftType);
                                //         $ShiftHour = "00:00:00";
                                //         foreach ($dtScheduleShift as $key => $value) {
                                //             if ($value["type"] === 'temp_shift') {
                                //                 $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //                 $Break  = $value->update_break;
                                //                 $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //             } else {
                                //                 $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //                 $Break  = $value->break;
                                //                 $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //             }

                                //             if ( $EndShiftTime > ($FirstClockInDate . " 00:00:00")) {
                                //                 $hour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockInDate . " 00:00:00", $Break);
                                //             } else {
                                //                 $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                //             }				
                                //             $ShiftHour = $this->summationTime($ShiftHour, $hour);
                                //         }
                                //         //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)		
                                //         $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $ShiftHour);

                                //         //Pattern1-7の対象期間開始日の前日からのシフト時間を集計する。
                                //         $dtSchedulePre = $ScheduleTbl->getALLShiftScheduleShiftTarget($ShopIDList[$i], $StartShift, $AppNotStampedShiftType);
                                //         $totalHour = "00:00:00";
                                //         foreach ($dtSchedulePre as $key => $value) {
                                //             if ($value->type === 'temp_shift') {
                                //                 $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //                 $DayBeforeBreak = $value->update_break;
                                //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //             } else {
                                //                 $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //                 $DayBeforeBreak = $value->break;
                                //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //             }
                                //             $start1 = $DayBeforeStartShiftTime;
                                //             $end1   = $StartShift . " 00:00:00";
                                //             $start2 = $end1;
                                //             $end2   = $DayBeforeEndShiftTime;
                                //             $break  = $DayBeforeBreak;
                                //             //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //             $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //             //集計項目
                                //             $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                //         }
                                //         //PatternPast[]	←	PatternPast[] + 計算した労働時間	
                                //         $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);
                                //     }

                                //     //・Pattern1-7の最初の打刻日の前日から打刻日時以前の確定シフト時間を集計する。 ( PatternPast[] の開始日 <= FirstClockInのDate <= PatternPast[] の終了日 の場合)
                                //     if( $StartShift <= $FirstClockInDate && $FirstClockInDate <= $EndShift){
                                //         //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                                //         $totalHour = "00:00:00";
                                //         //・FirstClockInの前日からFirstClockInまでの確定シフト時間を取得する。
                                //         $dtSchedule = $ScheduleTbl->getALLScheduleShiftFirstClockIn($ShopIDList[$i], $FirstClockInPre, $FirstClockInDate, $AppNotStampedShiftType);
                                //         foreach ($dtSchedule as $key => $value) {
                                //             if ($value->type === 'temp_shift') {
                                //                 $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //                 $DayBeforeBreak = $value->update_break;
                                //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //             } else {
                                //                 $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //                 $DayBeforeBreak = $value->break;
                                //                 $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //             }
                                //             $start1 = $DayBeforeStartShiftTime;
                                //             $end1   = $FirstClockInDate . " 00:00:00";
                                //             $start2 = $end1;
                                //             $end2   = $DayBeforeEndShiftTime;
                                //             $break  = $DayBeforeBreak;
                                //             //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //             $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //             //最初の打刻が、シフト時間内の場合、シフト時間から、その差分を引く。
                                //             //< DayBeforeEndShiftTime <= ShopIDList[].FirstClockIn の場合 >															
                                //             if ( $DayBeforeEndShiftTime <= $FirstClockIn) {
                                //                 //PatternPast[]		←	PatternPast[] + 当日労働時間の計算結果							
                                //                 $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                //             } else {
                                //                 //< DayBeforeEndShiftTime > ShopIDList[].FirstClockIn の場合 >
                                //                 //PatternPast[] + 当日労働時間の計算結果 -  ( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )	
                                //                 //PatternPast[] + 当日労働時間の計算結果
                                //                 $hourstart = $this->summationTime($totalHour, $data["WorkHour"]);
                                //                 //( DayBeforeEndShiftTime - ShopIDList[].FirstClockIn )
                                //                 $ShiftTime = Chronos::parse($DayBeforeEndShiftTime);
                                //                 $FirstClock = Chronos::parse($FirstClockIn);
                                //                 $diff = $FirstClock->diff($ShiftTime);
                                //                 $hourend = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                //                 if ($hourstart > $hourend) $totalHour = $this->subtractionTime($hourstart, $hourend);			
                                //             }
                                //         }
                                //         $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);

                                //         //・FirstClockInの日で最初の打刻以前の確定シフト時間を計算する。
                                //         $dtSchedule = $ScheduleTbl->getScheduleALLShiftTimeFirstClockIn($ShopIDList[$i], $FirstClockInDate . " 00:00:00", $FirstClockIn, $AppNotStampedShiftType);
                                //         $ShiftHour = "00:00:00";
                                //         $SumShiftHour = "00:00:00";
                                //         foreach ($dtSchedule as $key => $value) {
                                //             if ($value->type === 'temp_shift') {
                                //                 $StartShiftTime =  $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //                 $ShiftBreak = $value->update_break;
                                //                 $EndShiftTime =  $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //             } else {
                                //                 $StartShiftTime =  $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //                 $ShiftBreak = $value->break;
                                //                 $EndShiftTime =  $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //             }
                                //             if ($EndShiftTime <= $FirstClockIn) {
                                //                 $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                //             } else {
                                //                 // ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合
                                //                 $StartShiftTime = Chronos::parse($StartShiftTime);
                                //                 $FirstClock = Chronos::parse($FirstClockIn);
                                //                 $diff = $FirstClock->diff($StartShiftTime);
                                //                 $time1 = sprintf('%02d:%02d:%02d', ($diff->days * 24) + $diff->h, $diff->i, $diff->s);
                                //                 $time2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                //                 //<  ( FirstClockIn - StartShiftTime ) >= ( EndShiftTime - StartShiftTime - ShiftBreak )  の場合>
                                //                 if ( $time1 >= $time2 ) {
                                //                     //最初の打刻以前の労働時間が予定シフト時間以上の場合、休憩時間は取得済みとして計算する。
                                //                     $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockIn, $ShiftBreak);
                                //                 } else {
                                //                     $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $FirstClockIn, 0);
                                //                 }
                                //             }
                                //             $SumShiftHour = $this->summationTime($SumShiftHour, $ShiftHour);
                                //         }
                                //         //PatternPast[]	←	PatternPast[] + 計算した労働時間	
                                //         $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $SumShiftHour);
                                //     }
                                // }
                                //28 hours limit(過去初回打刻日より前)
                                //・PatternPast[] の終了日 < FirstClockInのDate の場合の集計処理を行う。
                                // if ( $EndShift < $FirstClockInDate) {
                                //     $dtScheduleShift = $ScheduleTbl->getALLShiftScheduleShiftPattern($ShopIDList[$i], $StartShift, $EndShift, $AppNotStampedShiftType);
                                //     $ShiftHour = "00:00:00";
                                //     foreach ($dtScheduleShift as $key => $value) {
                                //         if ($value["type"] === 'temp_shift') {
                                //             $StartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //             $Break  = $value->update_break;
                                //             $EndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //         } else {
                                //             $StartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //             $Break  = $value->break;
                                //             $EndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //         }
                                //         $EndNextDate = date( 'Y-m-d', strtotime('+1 day' , strtotime ( $EndShift )));

                                //         if ( $EndShiftTime > ($EndNextDate . " 00:00:00")) {
                                //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndNextDate . " 00:00:00", $Break);
                                //         } else {
                                //             $hour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                //         }				
                                //         $ShiftHour = $this->summationTime($ShiftHour, $hour);
                                //     }
                                //     //PatternPast[]	←	PatternPast[] + SUM(ShiftHour)		
                                //     $PatternPast[$j]["WorkHour"]  = $this->summationTime($PatternPast[$j]["WorkHour"], $ShiftHour);

                                //     //Pattern1-7の対象期間開始日の前日からのシフト時間を集計する。
                                //     $dtSchedulePre = $ScheduleTbl->getALLShiftScheduleShiftTarget($ShopIDList[$i], $StartShift, $AppNotStampedShiftType);
                                //     $totalHour = "00:00:00";
                                //     foreach ($dtSchedulePre as $key => $value) {
                                //         if ($value->type === 'temp_shift') { 
                                //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->update_start, 'Y-m-d H:i:00');
                                //             $DayBeforeBreak = $value->update_break;
                                //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->update_end, 'Y-m-d H:i:00');
                                //         } else {
                                //             $DayBeforeStartShiftTime = $this->checkNullFormatDate($value->start, 'Y-m-d H:i:00');
                                //             $DayBeforeBreak = $value->break;
                                //             $DayBeforeEndShiftTime = $this->checkNullFormatDate($value->end, 'Y-m-d H:i:00');
                                //         }
                                //         $start1 = $DayBeforeStartShiftTime;
                                //         $end1   = $StartShift . " 00:00:00";
                                //         $start2 = $end1;
                                //         $end2   = $DayBeforeEndShiftTime;
                                //         $break  = $DayBeforeBreak;
                                //         //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                //         $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //         //集計項目
                                //         $totalHour = $this->summationTime($totalHour, $data["WorkHour"]);
                                //     }
                                //     //PatternPast[]	←	PatternPast[] + 計算した労働時間	
                                //     $PatternPast[$j]["WorkHour"] = $this->summationTime($PatternPast[$j]["WorkHour"], $totalHour);
                                // }
                            }
                        }
                        // }    
                        //「・未来の労働時間を計算する」
                        if($PatternSchedule[$j]['start'] > $CurrentDate.' 00:00:00' && $PatternSchedule[$j]['flg_schedule']){
                            //・チェック対象期間が現在日よりあとの場合 ( 28CheckStartDate > CurrentDate の場合)
                            // if($CurrentDate > $_28CheckEndDate){    
                            // if($_28CheckStartDate > $CurrentDate ){     
                            // $CurrentDateNext = date( 'Y-m-d', strtotime('+1 days', strtotime($CurrentDate)));         
                            $StartShift	= date( 'Y-m-d', strtotime($PatternSchedule[$j]["start"]));
                            $EndShift	= date( 'Y-m-d', strtotime($PatternSchedule[$j]["end"]));

                            $dtSch = $ScheduleTbl->getShiftScheduleShiftFuture($ShopIDList[$i], $StartShift, $EndShift, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $StartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $Break = $value["update_break"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $StartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $Break = $value["break"];
                                    $EndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }

                                $EndShiftNext = date( 'Y-m-d', strtotime('+1 days', strtotime($EndShift)));
                                //IF(EndShiftTime > EndShift + 1day + ' 00:00:00', EndShift + 1day  + ' 00:00:00',  EndShiftTime) - StartShiftTime - Break
                                if ($EndShiftTime > $EndShiftNext . " 00:00:00") {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftNext . " 00:00:00", $Break);
                                } else {
                                    $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $Break);
                                }
                                $total = $this->summationTime($total, $ShiftHour);
                            }
                            //PatternSchedule[]		←		SUM(ShiftHour)				
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);

                            $StartShiftPre = date( 'Y-m-d', strtotime('-1 day', strtotime($StartShift)));
                            //・対象期間開始日の前日からの確定シフト時間
                            $dtSch = $ScheduleTbl->getShiftScheduleShiftStartEndFuture($ShopIDList[$i], $StartShiftPre, $StartShift, $SearchShiftType, $TotalType);
                            $total = "00:00:00";
                            foreach ($dtSch as $key => $value) {
                                if ($TotalType === 'app' && $value["type"] === 'temp_shift') {
                                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["update_start"], 'Y-m-d H:i:00');
                                    $DayBeforeBreak = $value["update_break"];
                                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["update_end"], 'Y-m-d H:i:00');
                                } else {
                                    $DayBeforeStartShiftTime = $this->checkNullFormatDate($value["start"], 'Y-m-d H:i:00');
                                    $DayBeforeBreak = $value["break"];
                                    $DayBeforeEndShiftTime = $this->checkNullFormatDate($value["end"], 'Y-m-d H:i:00');
                                }
                                $start1 = $DayBeforeStartShiftTime;
                                $end1   = $StartShift . " 00:00:00";
                                $start2 = $end1;
                                $end2   = $DayBeforeEndShiftTime;
                                $break  = $DayBeforeBreak;
                                //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                                $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                                //集計項目
                                $total = $this->summationTime($total, $data["WorkHour"]);
                            }
                            //PatternSchedule[]		←		PatternSchedule[] + 計算した労働時間									
                            $PatternSchedule[$j]["WorkHour"]  = $this->summationTime($PatternSchedule[$j]["WorkHour"], $total);
                            // }
                        }
                    }
                }
            }
        }

        // チェック対象期間内にCurrentDateが含まれる場合、CurrentDateの労働時間を計算する。（28CheckStartDate <= CurrentDate <= 28CheckEndtDate の場合
        if($_28CheckStartDate <= $CurrentDate && $CurrentDate <= $_28CheckEndDate){
            //---------------log start---------------------
            $this->writeLog28h('UserController', 'CalculateShiftWorkTime28Hour', '28 hour limit - チェック対象期間内にCurrentDateが含まれる場合、CurrentDateの労働時間を計算する。（28CheckStartDate <= CurrentDate <= 28CheckEndtDate の場合', '', $CurrentDate, '');
            //---------------log end------------------------
            $TodayWorkHour = "00:00:00";
            //・最新の打刻情報が取得できた場合 ( LatestWorkID != null )
            if (!is_null($LatestWorkID)) {
                //・ LatestWorkStartTimeのDate < CurrentDate AND LatestWorkEndTime = null の場合、下記の処理を行う。
                if($LatestWorkStart < $CurrentDate && is_null($LatestWorkEndTime)) {
                    //・休憩中の場合（ LatestStartBreakTime != null）
                    if(!is_null($LatestStartBreakTime)) {
                        $start1 = $LatestWorkStartTime;
                        $end1   = $CurrentDate . " 00:00:00";
                        $start2 = $end1;
                        $end2   = ($LatestStartBreakTime <=  $end1) ? $end1 : $LatestStartBreakTime;
                        $break  = $LatestBreak;
                    } else {
                        //・休憩中以外の場合（ LatestStartBreakTime = null）
                        $start1 = $LatestWorkStartTime;
                        $end1   = $CurrentDate . " 00:00:00";
                        $start2 = $end1;
                        $end2   = $CurrentDateTime;
                        $break  = $LatestBreak;
                        $rs["ClockIn"] = "yes";
                    }
                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                    $rs["TodayWorkHour"] = $data["WorkHour"];
                    $rs["PreviousDayUsedBreakTime"] = $break;
                }
                //・ LatestWorkStartTimeのDate < CurrentDate AND LatestWorkEndTimeのDate = CurrentDate の場合、下記の処理を行う。
                if ($LatestWorkStart < $CurrentDate && $LatestWorkEnd == $CurrentDate) {
                    $start1 = $LatestWorkStartTime;
                    $end1   = $CurrentDate . " 00:00:00";
                    $start2 = $end1;
                    $end2   = $LatestWorkEndTime;
                    $break  = $LatestBreak;
                    //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                    $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                    $TodayWorkHour = $this->summationTime($TodayWorkHour, $data["WorkHour"]);
                    $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TodayWorkHour);
                }
            }
            //・最新の打刻が取得できない OR 最新打刻が当日の場合、下記の処理を行う。( LatestWorkID = null OR LatestWorkStartTimeのDate = CurrentDate )																															
            // if (is_null($LatestWorkID) || $LatestWorkStart == $CurrentDate) {
            //ShopIDList のshop_id単位で以下の処理をLoopする。               													
            for ($j=0; $j < sizeof($ShopIDList); $j++) {
                $TodayWorkHour = "00:00:00";
                // Delete v.0.12.0
                // if($ShopIDList[$j]['FirstClockIn'] !== null && date( 'Y-m-d' , strtotime( $ShopIDList[$j]['FirstClockIn']))  === $CurrentDate ){
                //     //最初の打刻が当日の場合、前日から当日の確定シフト時間を取得する。
                //     $DayBeforeStartShiftTime = null;
                //     $DayBeforeBreak = null;
                //     $DayBeforeEndShiftTime = null;
                //     $dtSchePre = $ScheduleTbl->getALLShiftSchePreDay($ShopIDList[$j], $CurrentDate, $AppNotStampedShiftType);
                //     if (sizeof($dtSchePre) > 0) {
                //         for ($i=0; $i < sizeof($dtSchePre); $i++) { 
                //             //・Record件数 > 0 の場合は、労働時間を計算する。
                //             if ($dtSchePre[$i]['type'] === 'temp_shift') {
                //                 $DayBeforeStartShiftTime = $dtSchePre[$i]["update_start"];
                //                 $DayBeforeBreak = $dtSchePre[$i]["update_break_times"];
                //                 $DayBeforeEndShiftTime = $dtSchePre[$i]["update_end"];
                //             } else {
                //                 $DayBeforeStartShiftTime = $dtSchePre[$i]["start"];
                //                 $DayBeforeBreak = $dtSchePre[$i]["break_times"];
                //                 $DayBeforeEndShiftTime = $dtSchePre[$i]["end"];
                //             }
                //             $start1 = $DayBeforeStartShiftTime;
                //             $end1   = $CurrentDate . " 00:00:00";
                //             $start2 = $end1;
                //             $end2   = $DayBeforeEndShiftTime <= $ShopIDList[$j]['FirstClockIn'] ? $DayBeforeEndShiftTime : $ShopIDList[$j]['FirstClockIn'];
                //             $break  = $DayBeforeBreak;
                //             // }
                //             //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                //             $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                //             $TodayWorkHour = $this->summationTime($TodayWorkHour, $data["WorkHour"]);
                //         }
                //         $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TodayWorkHour);
                //     }
                // }
                //最初の打刻が当日より前の場合（ ShopIDList[].FirstClockInのDate < CurrentDate AND ShopIDList[].FirstClockIn != null）
                // if($ShopIDList[$j]['FirstClockIn'] !== null && date( 'Y-m-d' , strtotime( $ShopIDList[$j]['FirstClockIn'])) < $CurrentDate ){
                $DayBeforeStartWorkTime = null;
                $DayBeforeStartBreak = null;
                $DayBeforeEndWorkTime = null;
                $dtAttPre = $AttendanceTbl->getAttendanceShiftPreDay($ShopIDList[$j], $CurrentDate, $LatestWorkID);
                if (sizeof($dtAttPre) > 0) {
                    for ($i=0; $i < sizeof($dtAttPre); $i++) {
                        //・Record件数 > 0 の場合は、労働時間を計算する。
                        $DayBeforeStartWorkTime = $this->checkNullFormatDate($dtAttPre[$i]->start, 'Y-m-d H:i:00');
                        $DayBeforeStartBreak = $dtAttPre[$i]->break;
                        $DayBeforeEndWorkTime = $this->checkNullFormatDate($dtAttPre[$i]->end, 'Y-m-d H:i:00');

                        $start1 = $DayBeforeStartWorkTime;
                        $end1   = $CurrentDate . " 00:00:00";
                        $start2 = $end1;
                        $end2   = $DayBeforeEndWorkTime;
                        $break  = $DayBeforeStartBreak;
                        //計算は[補足_労働時間計算]Sheetの「1. 日をまたぐ労働時間の計算について」を参照する。
                        $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                        $TodayWorkHour = $this->summationTime($TodayWorkHour, $data["WorkHour"]);

                    }
                    $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TodayWorkHour);
                }
                // }
            }
            // }

            //・当日の労働時間を取得する。
            //・最新の打刻が取得できた( LatestWorkID != null ) AND LatestWorkStartTimeのDate = CurrentDate の場合、下記の処理を行う。
            $TotalWorkHour = "00:00:00";
            $SumHour = "00:00:00";
            if (!is_null($LatestWorkID) && ($LatestWorkStart == $CurrentDate)) {
                //・最新の勤怠以前の労働時間を計算する。
                $dtAttenLast = $AttendanceTbl->getAttenLast($UserEmployIDList, $mergeShopID, $CurrentDate, $LatestWorkID, $CurrentDateTime);
                if (sizeof($dtAttenLast) > 0) {
                    for ($i=0; $i < sizeof($dtAttenLast); $i++) {
                        $StartWorkTime = $this->checkNullFormatDate($dtAttenLast[$i]["start"], 'Y-m-d H:i:00');
                        $Break =  $dtAttenLast[$i]["break"];
                        $EndWorkTime = $this->checkNullFormatDate($dtAttenLast[$i]["end"], 'Y-m-d H:i:00');

                        $WorkHour = $this->calWorkTimeToBreak($StartWorkTime, $EndWorkTime, $Break);
                        //集計項目
                        $SumHour = $this->summationTime($SumHour, $WorkHour);
                    }
                }
                //・最新の労働時間を足す。
                $hour = "00:00:00";
                if (!is_null($LatestWorkEndTime)) {
                    //TodayWorkHour + ( LatestWorkEndTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                    $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $LatestWorkEndTime, $LatestBreak);
                    $TotalWorkHour = $this->summationTime($hour, $SumHour);
                } else {
                    if (is_null($LatestStartBreakTime)) {
                        //TodayWorkHour + ( CurrentDateTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                        $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $CurrentDateTime, $LatestBreak);
                        $TotalWorkHour = $this->summationTime($hour, $SumHour);
                        $rs["ClockIn"] = "yes";
                    } else  {
                        //TodayWorkHour + ( LatestStartBreakTime - LatestWorkStartTime -  LatestBreak) + SUM(WorkHour)
                        $hour = $this->calWorkTimeToBreak($LatestWorkStartTime, $LatestStartBreakTime, $LatestBreak);
                        $TotalWorkHour = $this->summationTime($hour, $SumHour);
                    }
                }
                $rs["TodayWorkHour"] = $this->summationTime($rs["TodayWorkHour"], $TotalWorkHour);

                if($LatestWorkEndTime === null && $LatestStartBreakTime === null){
                    $rs["TodayUsedBreakTime"]= $LatestBreak;
                }else if($LatestWorkEndTime === null && $LatestStartBreakTime !== null){
                    // $rs["TodayUsedBreakTime"] = $this->calWorkTimeToBreak($LatestStartBreakTime, $CurrentDateTime, $LatestBreak);
                    $rs["TodayUsedBreakTime"] = $LatestBreak;
                }
            }

         
            $DayBeforeShiftHour = "00:00:00";
            for ($j=0; $j < sizeof($ShopIDList); $j++) {
                if ($ShopIDList[$j]['FirstClockIn'] !== null) {
                    $arrEmployee = [];
                    array_push($arrEmployee, $ShopIDList[$j]['employee_id']);
                    $dtScheBefor = $ScheduleTbl->getALLShiftScheDayBefore($arrEmployee, $ShopIDList[$j]["shop_id"], $CurrentDate, $CurrentDateTime, $SearchShiftType, $TotalType);
                    if (sizeof($dtScheBefor) > 0) {
                        for ($i=0; $i < sizeof($dtScheBefor); $i++) {
                            //・Record件数 > 0 の場合は、労働時間を計算する。
                            if ($TotalType == 'app' && $dtScheBefor[$i]->type === 'temp_shift') {
                                $ShiftBreak = $dtScheBefor[$i]->update_break_times;
                                $StartShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->update_start, 'Y-m-d H:i:00');
                                $EndShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->update_end, 'Y-m-d H:i:00');
                            } else {
                                $ShiftBreak = $dtScheBefor[$i]->break_times;
                                $StartShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->start, 'Y-m-d H:i:00');
                                $EndShiftTime = $this->checkNullFormatDate($dtScheBefor[$i]->end, 'Y-m-d H:i:00');
                            }

                            $start1 = $StartShiftTime;
                            $end1   = $CurrentDate . " 00:00:00";
                            $start2 = $end1;
                            $end2   = $EndShiftTime;
                            $break  = $ShiftBreak;
                            //当日の労働時間
                            $data = $this->calculationOfWorking($start1, $end1, $start2, $end2, $break);
                            //現在時間の残りシフト時間	←	EndShiftTime - CurrentDateTime
                            $timeRemaining = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                            if ($data["WorkHour"] < $timeRemaining) {
                                $DayBeforeShiftHour = $this->summationTime($DayBeforeShiftHour, $data["WorkHour"]);
                            } else {
                                $DayBeforeShiftHour = $this->summationTime($DayBeforeShiftHour, $timeRemaining);
                            }
                        }
                    }
                }
            }
            $TodayShiftHour = "00:00:00";
            $ShiftIDCurrentTime = null;
            $ShiftHourOnTheDay = "00:00:00";
            for ($j=0; $j < sizeof($ShopIDList); $j++) {
                if($ShopIDList[$j]['FirstClockIn'] !== null) {
                    $SumShiftHour = "00:00:00";
                    $dtScheShiftCur = $ScheduleTbl->getALLShiftScheDayCur($ShopIDList[$j]['employee_id'], $ShopIDList[$j]['shop_id'], $CurrentDate, $CurrentDateTime, null, $SearchShiftType, $TotalType);
                    if (sizeof($dtScheShiftCur) > 0) {
                        for ($i=0; $i < sizeof($dtScheShiftCur); $i++) {
                            if ($TotalType === 'app' && $dtScheShiftCur[$i]->type === 'temp_shift') {
                                $StartShiftTime = $this->checkNullFormatDate($dtScheShiftCur[$i]->update_start, 'Y-m-d H:i:00');
                                $ShiftBreak = $dtScheShiftCur[$i]->update_break;
                                $EndShiftTime = $this->checkNullFormatDate($dtScheShiftCur[$i]->update_end, 'Y-m-d H:i:00');
                            } else {
                                $StartShiftTime = $this->checkNullFormatDate($dtScheShiftCur[$i]->start, 'Y-m-d H:i:00');
                                $ShiftBreak = $dtScheShiftCur[$i]->break;
                                $EndShiftTime = $this->checkNullFormatDate($dtScheShiftCur[$i]->end, 'Y-m-d H:i:00');
                            }

                            $NextCurDateTime = date( 'Y-m-d 00:00:00' , strtotime('+1 day' , strtotime ( $CurrentDate )));

                            if ( $EndShiftTime >= $NextCurDateTime ) $EndShiftTime = $NextCurDateTime;

                            if ($StartShiftTime < $CurrentDateTime){
                                $time1 = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, 0);
                                $time2 = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                                if($time1 >= $time2) {
                                    $ShiftHour = $this->calWorkTimeToBreak($CurrentDateTime, $EndShiftTime, $ShiftBreak);
                                } else {
                                    $ShiftHour = $time1;
                                }
                            } else {
                                $ShiftHour = $this->calWorkTimeToBreak($StartShiftTime, $EndShiftTime, $ShiftBreak);
                            }
                            // $SumShiftHour = date('H:i:s', strtotime($SumShiftHour) + strtotime($ShiftHour));
                            $SumShiftHour = $this->summationTime($SumShiftHour, $ShiftHour);
                        }
                    }
                    //ShiftHourOnTheDay (after the current time)
                    $ShiftHourOnTheDay = $this->summationTime($ShiftHourOnTheDay, $SumShiftHour);
                }
            }

            //Shift時間を合算する。
            $rs["TodayShiftHour"] = $this->summationTime($DayBeforeShiftHour, $TodayShiftHour);
            $rs["TodayShiftHour"] = $this->summationTime($rs["TodayShiftHour"], $ShiftHourOnTheDay);

            //・労働時間と確定シフト時間を合算する。
            $rs["TargetDayWorkHour"] = $this->summationTime($rs["TodayShiftHour"] , $rs["TodayWorkHour"]);
        }
    }
}
